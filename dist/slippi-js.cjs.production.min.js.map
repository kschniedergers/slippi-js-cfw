{"version":3,"file":"slippi-js.cjs.production.min.js","sources":["../src/melee/characterUtils.ts","../src/melee/moveUtils.ts","../src/melee/stageUtils.ts","../src/melee/types.ts","../src/stats/common.ts","../src/stats/actions.ts","../src/stats/combos.ts","../src/types.ts","../src/stats/inputs.ts","../src/stats/conversions.ts","../src/stats/overall.ts","../src/stats/stats.ts","../src/stats/stocks.ts","../src/utils/exists.ts","../src/stats/targets.ts","../src/console/communication.ts","../src/console/types.ts","../src/console/consoleConnection.ts","../src/console/dolphinConnection.ts","../src/utils/slpReader.ts","../src/utils/slpStream.ts","../src/utils/fullwidth.ts","../src/utils/slpFile.ts","../src/utils/slpFileWriter.ts","../src/utils/slpParser.ts","../src/utils/rollbackCounter.ts","../src/SlippiGame.ts","../src/utils/homeRunDistance.ts","../src/utils/getWinners.ts","../src/melee/animationUtils.ts","../src/utils/gameTimer.ts"],"sourcesContent":["import characters from \"./characters.json\";\n\nexport type CharacterColor = string;\nconst DEFAULT_COLOR: CharacterColor = \"Default\";\n\nexport type CharacterInfo = {\n  id: number;\n  name: string;\n  shortName: string;\n  colors: CharacterColor[];\n};\n\nexport const UnknownCharacter: CharacterInfo = {\n  id: -1,\n  name: \"Unknown Character\",\n  shortName: \"Unknown\",\n  colors: [DEFAULT_COLOR],\n};\n\ntype CharacterId = keyof typeof characters;\n\nfunction generateCharacterInfo(\n  id: number,\n  info?: {\n    name: string;\n    shortName?: string;\n    colors?: CharacterColor[];\n  },\n): CharacterInfo {\n  if (!info) {\n    return UnknownCharacter;\n  }\n\n  return {\n    id,\n    name: info.name,\n    shortName: info.shortName ?? info.name,\n    colors: [DEFAULT_COLOR, ...(info.colors ?? [])],\n  };\n}\n\nexport function getAllCharacters(): CharacterInfo[] {\n  return Object.entries(characters)\n    .map(([id, data]) => generateCharacterInfo(parseInt(id, 10), data))\n    .sort((a, b) => a.id - b.id);\n}\n\nexport function getCharacterInfo(externalCharacterId: number): CharacterInfo {\n  const data = characters[externalCharacterId.toString() as CharacterId];\n  return generateCharacterInfo(externalCharacterId, data);\n}\n\nexport function getCharacterShortName(externalCharacterId: number): string {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.shortName;\n}\n\nexport function getCharacterName(externalCharacterId: number): string {\n  const character = getCharacterInfo(externalCharacterId);\n  return character.name;\n}\n\n// Return a human-readable color from a characterCode.\nexport function getCharacterColorName(externalCharacterId: number, characterColor: number): CharacterColor {\n  const character = getCharacterInfo(externalCharacterId);\n  const color = character.colors[characterColor];\n  if (color) {\n    return color;\n  }\n  return DEFAULT_COLOR;\n}\n","import moveNames from \"./moves.json\";\n\nexport type Move = {\n  id: number;\n  name: string;\n  shortName: string;\n};\n\nexport const UnknownMove: Move = {\n  id: -1,\n  name: \"Unknown Move\",\n  shortName: \"unknown\",\n};\n\ntype MoveId = keyof typeof moveNames;\n\nexport function getMoveInfo(moveId: number): Move {\n  const moveName = moveNames[moveId.toString() as MoveId];\n  if (!moveName) {\n    return UnknownMove;\n  }\n  return {\n    id: moveId,\n    name: moveName.name,\n    shortName: moveName.shortName,\n  };\n}\n\nexport function getMoveShortName(moveId: number): string {\n  const move = getMoveInfo(moveId);\n  return move.shortName;\n}\n\nexport function getMoveName(moveId: number): string {\n  const move = getMoveInfo(moveId);\n  return move.name;\n}\n","import stageNames from \"./stages.json\";\n\nexport type StageInfo = {\n  id: number;\n  name: string;\n};\n\nexport const UnknownStage: StageInfo = {\n  id: -1,\n  name: \"Unknown Stage\",\n};\n\ntype StageId = keyof typeof stageNames;\n\nexport function getStageInfo(stageId: number): StageInfo {\n  const stageName = stageNames[stageId.toString() as StageId];\n  if (!stageName) {\n    return UnknownStage;\n  }\n  return {\n    id: stageId,\n    name: stageName,\n  };\n}\n\nexport function getStageName(stageId: number): string {\n  const stage = getStageInfo(stageId);\n  return stage.name;\n}\n","export enum Character {\n  CAPTAIN_FALCON = 0,\n  DONKEY_KONG = 1,\n  FOX = 2,\n  GAME_AND_WATCH = 3,\n  KIRBY = 4,\n  BOWSER = 5,\n  LINK = 6,\n  LUIGI = 7,\n  MARIO = 8,\n  MARTH = 9,\n  MEWTWO = 10,\n  NESS = 11,\n  PEACH = 12,\n  PIKACHU = 13,\n  ICE_CLIMBERS = 14,\n  JIGGLYPUFF = 15,\n  SAMUS = 16,\n  YOSHI = 17,\n  ZELDA = 18,\n  SHEIK = 19,\n  FALCO = 20,\n  YOUNG_LINK = 21,\n  DR_MARIO = 22,\n  ROY = 23,\n  PICHU = 24,\n  GANONDORF = 25,\n  MASTER_HAND = 26,\n  WIREFRAME_MALE = 27,\n  WIREFRAME_FEMALE = 28,\n  GIGA_BOWSER = 29,\n  CRAZY_HAND = 30,\n  SANDBAG = 31,\n  POPO = 32,\n}\n\nexport enum Stage {\n  FOUNTAIN_OF_DREAMS = 2,\n  POKEMON_STADIUM = 3,\n  PEACHS_CASTLE = 4,\n  KONGO_JUNGLE = 5,\n  BRINSTAR = 6,\n  CORNERIA = 7,\n  YOSHIS_STORY = 8,\n  ONETT = 9,\n  MUTE_CITY = 10,\n  RAINBOW_CRUISE = 11,\n  JUNGLE_JAPES = 12,\n  GREAT_BAY = 13,\n  HYRULE_TEMPLE = 14,\n  BRINSTAR_DEPTHS = 15,\n  YOSHIS_ISLAND = 16,\n  GREEN_GREENS = 17,\n  FOURSIDE = 18,\n  MUSHROOM_KINGDOM = 19,\n  MUSHROOM_KINGDOM_2 = 20,\n  VENOM = 22,\n  POKE_FLOATS = 23,\n  BIG_BLUE = 24,\n  ICICLE_MOUNTAIN = 25,\n  ICETOP = 26,\n  FLAT_ZONE = 27,\n  DREAMLAND = 28,\n  YOSHIS_ISLAND_N64 = 29,\n  KONGO_JUNGLE_N64 = 30,\n  BATTLEFIELD = 31,\n  FINAL_DESTINATION = 32,\n  TARGET_TEST_MARIO = 33,\n  TARGET_TEST_CAPTAIN_FALCON = 34,\n  TARGET_TEST_YOUNG_LINK = 35,\n  TARGET_TEST_DONKEY_KONG = 36,\n  TARGET_TEST_DR_MARIO = 37,\n  TARGET_TEST_FALCO = 38,\n  TARGET_TEST_FOX = 39,\n  TARGET_TEST_ICE_CLIMBERS = 40,\n  TARGET_TEST_KIRBY = 41,\n  TARGET_TEST_BOWSER = 42,\n  TARGET_TEST_LINK = 43,\n  TARGET_TEST_LUIGI = 44,\n  TARGET_TEST_MARTH = 45,\n  TARGET_TEST_MEWTWO = 46,\n  TARGET_TEST_NESS = 47,\n  TARGET_TEST_PEACH = 48,\n  TARGET_TEST_PICHU = 49,\n  TARGET_TEST_PIKACHU = 50,\n  TARGET_TEST_JIGGLYPUFF = 51,\n  TARGET_TEST_SAMUS = 52,\n  TARGET_TEST_SHEIK = 53,\n  TARGET_TEST_YOSHI = 54,\n  TARGET_TEST_ZELDA = 55,\n  TARGET_TEST_GAME_AND_WATCH = 56,\n  TARGET_TEST_ROY = 57,\n  TARGET_TEST_GANONDORF = 58,\n  RACE_TO_THE_FINISH = 82,\n  GRAB_THE_TROPHIES = 83,\n  HOME_RUN_CONTEST = 84,\n  ALL_STAR_LOBBY = 85,\n  EVENT_ONE = 202,\n  EVENT_EIGHTEEN = 203,\n  EVENT_THREE = 204,\n  EVENT_FOUR = 205,\n  EVENT_FIVE = 206,\n  EVENT_SIX = 207,\n  EVENT_SEVEN = 208,\n  EVENT_EIGHT = 209,\n  EVENT_NINE = 210,\n  EVENT_TEN_PART_ONE = 211,\n  EVENT_ELEVEN = 212,\n  EVENT_TWELVE = 213,\n  EVENT_THIRTEEN = 214,\n  EVENT_FOURTEEN = 215,\n  EVENT_THIRTY_SEVEN = 216,\n  EVENT_SIXTEEN = 217,\n  EVENT_SEVENTEEN = 218,\n  EVENT_TWO = 219,\n  EVENT_NINETEEN = 220,\n  EVENT_TWENTY_PART_ONE = 221,\n  EVENT_TWENTY_ONE = 222,\n  EVENT_TWENTY_TWO = 223,\n  EVENT_TWENTY_SEVEN = 224,\n  EVENT_TWENTY_FOUR = 225,\n  EVENT_TWENTY_FIVE = 226,\n  EVENT_TWENTY_SIX = 227,\n  EVENT_TWENTY_THREE = 228,\n  EVENT_TWENTY_EIGHT = 229,\n  EVENT_TWENTY_NINE = 230,\n  EVENT_THIRTY_PART_ONE = 231,\n  EVENT_THIRTY_ONE = 232,\n  EVENT_THIRTY_TWO = 233,\n  EVENT_THIRTY_THREE = 234,\n  EVENT_THIRTY_FOUR = 235,\n  EVENT_FORTY_EIGHT = 236,\n  EVENT_THIRTY_SIX_PART_ONE = 237,\n  EVENT_FIFTEEN = 238,\n  EVENT_THIRTY_EIGHT = 239,\n  EVENT_THIRTY_NINE = 240,\n  EVENT_FORTY_PART_ONE = 241,\n  EVENT_FORTY_ONE = 242,\n  EVENT_FORTY_TWO = 243,\n  EVENT_FORTY_THREE = 244,\n  EVENT_FORTY_FOUR = 245,\n  EVENT_FORTY_FIVE = 246,\n  EVENT_FORTY_SIX = 247,\n  EVENT_FORTY_SEVEN = 248,\n  EVENT_THIRTY_FIVE = 249,\n  EVENT_FORTY_NINE_PART_ONE = 250,\n  EVENT_FIFTY = 251,\n  EVENT_FIFTY_ONE = 252,\n  EVENT_TEN_PART_TWO = 253,\n  EVENT_TEN_PART_THREE = 254,\n  EVENT_TEN_PART_FOUR = 255,\n  EVENT_TEN_PART_FIVE = 256,\n  EVENT_TWENTY_PART_TWO = 257,\n  EVENT_TWENTY_PART_THREE = 258,\n  EVENT_TWENTY_PART_FOUR = 259,\n  EVENT_TWENTY_PART_FIVE = 260,\n  EVENT_THIRTY_PART_TWO = 261,\n  EVENT_THIRTY_PART_THREE = 262,\n  EVENT_THIRTY_PART_FOUR = 263,\n  EVENT_FORTY_PART_TWO = 264,\n  EVENT_FORTY_PART_THREE = 265,\n  EVENT_FORTY_PART_FOUR = 266,\n  EVENT_FORTY_PART_FIVE = 267,\n  EVENT_FORTY_NINE_PART_TWO = 268,\n  EVENT_FORTY_NINE_PART_THREE = 269,\n  EVENT_FORTY_NINE_PART_FOUR = 270,\n  EVENT_FORTY_NINE_PART_FIVE = 271,\n  EVENT_FORTY_NINE_PART_SIX = 272,\n  EVENT_THIRTY_SIX_PART_TWO = 273,\n  MULTI_MAN_MELEE = 285,\n}\n","import type { GameStartType, PostFrameUpdateType } from \"../types\";\n\nexport type StatsType = {\n  gameComplete: boolean;\n  lastFrame: number;\n  playableFrameCount: number;\n  stocks: StockType[];\n  conversions: ConversionType[];\n  combos: ComboType[];\n  actionCounts: ActionCountsType[];\n  overall: OverallType[];\n};\n\nexport type StadiumStatsType = HomeRunContestResultType | TargetTestResultType;\n\nexport type TargetTestResultType = {\n  type: \"target-test\";\n  targetBreaks: TargetBreakType[];\n};\n\nexport type HomeRunContestResultType = {\n  type: \"home-run-contest\";\n  distance: number;\n  units: \"feet\" | \"meters\";\n};\n\nexport type RatioType = {\n  count: number;\n  total: number;\n  ratio: number | null;\n};\n\nexport type PlayerIndexedType = {\n  playerIndex: number;\n  opponentIndex: number;\n};\n\nexport type DurationType = {\n  startFrame: number;\n  endFrame?: number | null;\n};\n\nexport type DamageType = {\n  startPercent: number;\n  currentPercent: number;\n  endPercent?: number | null;\n};\n\nexport type StockType = DurationType &\n  DamageType & {\n    playerIndex: number;\n    count: number;\n    deathAnimation?: number | null;\n  };\n\nexport type MoveLandedType = {\n  playerIndex: number;\n  frame: number;\n  moveId: number;\n  hitCount: number;\n  damage: number;\n};\n\nexport type ComboType = DurationType &\n  DamageType & {\n    playerIndex: number;\n    moves: MoveLandedType[];\n    didKill: boolean;\n    lastHitBy: number | null;\n  };\n\nexport type TargetBreakType = {\n  spawnId: number;\n  frameDestroyed: number | null;\n  positionX: number;\n  positionY: number;\n};\n\nexport type ConversionType = ComboType & {\n  openingType: string;\n};\n\nexport type ActionCountsType = {\n  playerIndex: number;\n  wavedashCount: number;\n  wavelandCount: number;\n  airDodgeCount: number;\n  dashDanceCount: number;\n  spotDodgeCount: number;\n  ledgegrabCount: number;\n  rollCount: number;\n  lCancelCount: {\n    success: number;\n    fail: number;\n  };\n  attackCount: {\n    jab1: number;\n    jab2: number;\n    jab3: number;\n    jabm: number;\n    dash: number;\n    ftilt: number;\n    utilt: number;\n    dtilt: number;\n    fsmash: number;\n    usmash: number;\n    dsmash: number;\n    nair: number;\n    fair: number;\n    bair: number;\n    uair: number;\n    dair: number;\n  };\n  grabCount: {\n    success: number;\n    fail: number;\n  };\n  throwCount: {\n    up: number;\n    forward: number;\n    back: number;\n    down: number;\n  };\n  groundTechCount: {\n    // tech away/in are in reference to the opponents position and not the stage\n    away: number;\n    in: number;\n    neutral: number;\n    fail: number;\n  };\n  wallTechCount: {\n    success: number;\n    fail: number;\n  };\n};\n\nexport type InputCountsType = {\n  buttons: number;\n  triggers: number;\n  joystick: number;\n  cstick: number;\n  total: number;\n};\n\nexport type OverallType = {\n  playerIndex: number;\n  inputCounts: InputCountsType;\n  conversionCount: number;\n  totalDamage: number;\n  killCount: number;\n  successfulConversions: RatioType;\n  inputsPerMinute: RatioType;\n  digitalInputsPerMinute: RatioType;\n  openingsPerKill: RatioType;\n  damagePerOpening: RatioType;\n  neutralWinRatio: RatioType;\n  counterHitRatio: RatioType;\n  beneficialTradeRatio: RatioType;\n};\n\nexport enum State {\n  // Animation ID ranges\n  DAMAGE_START = 0x4b,\n  DAMAGE_END = 0x5b,\n  CAPTURE_START = 0xdf,\n  CAPTURE_END = 0xe8,\n  GUARD_START = 0xb2,\n  GUARD_END = 0xb6,\n  GROUNDED_CONTROL_START = 0xe,\n  GROUNDED_CONTROL_END = 0x18,\n  SQUAT_START = 0x27,\n  SQUAT_END = 0x29,\n  DOWN_START = 0xb7,\n  DOWN_END = 0xc6,\n  TECH_START = 0xc7,\n  TECH_END = 0xcc,\n  DYING_START = 0x0,\n  DYING_END = 0xa,\n  CONTROLLED_JUMP_START = 0x18,\n  CONTROLLED_JUMP_END = 0x22,\n  GROUND_ATTACK_START = 0x2c,\n  GROUND_ATTACK_END = 0x40,\n  AERIAL_ATTACK_START = 0x41,\n  AERIAL_ATTACK_END = 0x4a,\n  ATTACK_FTILT_START = 0x33,\n  ATTACK_FTILT_END = 0x37,\n  ATTACK_FSMASH_START = 0x3a,\n  ATTACK_FSMASH_END = 0x3e,\n\n  // Animation ID specific\n  ROLL_FORWARD = 0xe9,\n  ROLL_BACKWARD = 0xea,\n  SPOT_DODGE = 0xeb,\n  AIR_DODGE = 0xec,\n  ACTION_WAIT = 0xe,\n  ACTION_DASH = 0x14,\n  ACTION_KNEE_BEND = 0x18,\n  GUARD_ON = 0xb2,\n  TECH_MISS_UP = 0xb7,\n  JAB_RESET_UP = 0xb9,\n  TECH_MISS_DOWN = 0xbf,\n  JAB_RESET_DOWN = 0xc1,\n  NEUTRAL_TECH = 0xc7,\n  FORWARD_TECH = 0xc8,\n  BACKWARD_TECH = 0xc9,\n  WALL_TECH = 0xca,\n  MISSED_WALL_TECH = 0xf7,\n  DASH = 0x14,\n  TURN = 0x12,\n  LANDING_FALL_SPECIAL = 0x2b,\n  JUMP_FORWARD = 0x19,\n  JUMP_BACKWARD = 0x1a,\n  FALL_FORWARD = 0x1e,\n  FALL_BACKWARD = 0x1f,\n  GRAB = 0xd4,\n  DASH_GRAB = 0xd6,\n  GRAB_WAIT = 0xd8,\n  PUMMEL = 0xd9,\n  CLIFF_CATCH = 0xfc,\n  THROW_UP = 0xdd,\n  THROW_FORWARD = 0xdb,\n  THROW_DOWN = 0xde,\n  THROW_BACK = 0xdc,\n  DAMAGE_FALL = 0x26,\n  ATTACK_JAB1 = 0x2c,\n  ATTACK_JAB2 = 0x2d,\n  ATTACK_JAB3 = 0x2e,\n  ATTACK_JABM = 0x2f,\n  ATTACK_DASH = 0x32,\n  ATTACK_UTILT = 0x38,\n  ATTACK_DTILT = 0x39,\n  ATTACK_USMASH = 0x3f,\n  ATTACK_DSMASH = 0x40,\n  AERIAL_NAIR = 0x41,\n  AERIAL_FAIR = 0x42,\n  AERIAL_BAIR = 0x43,\n  AERIAL_UAIR = 0x44,\n  AERIAL_DAIR = 0x45,\n\n  // Weird GnW IDs\n  GNW_JAB1 = 0x155,\n  GNW_JABM = 0x156,\n  GNW_DTILT = 0x159,\n  GNW_FSMASH = 0x15a,\n  GNW_NAIR = 0x15b,\n  GNW_BAIR = 0x15c,\n  GNW_UAIR = 0x15d,\n\n  // Peach FSMASH ID\n  // FSMASH1 = Golf Club, FSMASH2 = Frying Pan, FSMASH3 = Tennis Racket\n  PEACH_FSMASH1 = 0x15d,\n  PEACH_FSMASH2 = 0x15e,\n  PEACH_FSMASH3 = 0x15f,\n\n  // Command Grabs\n  BARREL_WAIT = 0x125,\n  COMMAND_GRAB_RANGE1_START = 0x10a,\n  COMMAND_GRAB_RANGE1_END = 0x130,\n\n  COMMAND_GRAB_RANGE2_START = 0x147,\n  COMMAND_GRAB_RANGE2_END = 0x152,\n}\n\nexport const Timers = {\n  PUNISH_RESET_FRAMES: 45,\n  RECOVERY_RESET_FRAMES: 45,\n  COMBO_STRING_RESET_FRAMES: 45,\n};\n\nexport function getSinglesPlayerPermutationsFromSettings(settings: GameStartType): PlayerIndexedType[] {\n  if (!settings || settings.players.length !== 2) {\n    // Only return opponent indices for singles\n    return [];\n  }\n\n  return [\n    {\n      playerIndex: settings.players[0]!.playerIndex,\n      opponentIndex: settings.players[1]!.playerIndex,\n    },\n    {\n      playerIndex: settings.players[1]!.playerIndex,\n      opponentIndex: settings.players[0]!.playerIndex,\n    },\n  ];\n}\n\nexport function didLoseStock(frame: PostFrameUpdateType, prevFrame: PostFrameUpdateType): boolean {\n  if (!frame || !prevFrame) {\n    return false;\n  }\n\n  return prevFrame.stocksRemaining! - frame.stocksRemaining! > 0;\n}\n\nexport function isInControl(state: number): boolean {\n  const ground = state >= State.GROUNDED_CONTROL_START && state <= State.GROUNDED_CONTROL_END;\n  const squat = state >= State.SQUAT_START && state <= State.SQUAT_END;\n  const groundAttack = state > State.GROUND_ATTACK_START && state <= State.GROUND_ATTACK_END;\n  const isGrab = state === State.GRAB;\n  // TODO: Add grounded b moves?\n  return ground || squat || groundAttack || isGrab;\n}\n\nexport function isTeching(state: number): boolean {\n  return state >= State.TECH_START && state <= State.TECH_END;\n}\n\nexport function isDown(state: number): boolean {\n  return state >= State.DOWN_START && state <= State.DOWN_END;\n}\n\nexport function isDamaged(state: number): boolean {\n  return (\n    (state >= State.DAMAGE_START && state <= State.DAMAGE_END) ||\n    state === State.DAMAGE_FALL ||\n    state === State.JAB_RESET_UP ||\n    state === State.JAB_RESET_DOWN\n  );\n}\n\nexport function isGrabbed(state: number): boolean {\n  return state >= State.CAPTURE_START && state <= State.CAPTURE_END;\n}\n\n// TODO: Find better implementation of 3 seperate ranges\nexport function isCommandGrabbed(state: number): boolean {\n  return (\n    ((state >= State.COMMAND_GRAB_RANGE1_START && state <= State.COMMAND_GRAB_RANGE1_END) ||\n      (state >= State.COMMAND_GRAB_RANGE2_START && state <= State.COMMAND_GRAB_RANGE2_END)) &&\n    state !== State.BARREL_WAIT\n  );\n}\n\nexport function isDead(state: number): boolean {\n  return state >= State.DYING_START && state <= State.DYING_END;\n}\n\nexport function calcDamageTaken(frame: PostFrameUpdateType, prevFrame: PostFrameUpdateType): number {\n  const percent = frame.percent ?? 0;\n  const prevPercent = prevFrame.percent ?? 0;\n\n  return percent - prevPercent;\n}\n","import get from \"lodash/get\";\nimport isEqual from \"lodash/isEqual\";\nimport keyBy from \"lodash/keyBy\";\nimport last from \"lodash/last\";\nimport set from \"lodash/set\";\nimport size from \"lodash/size\";\n\nimport type { FrameEntryType, GameStartType } from \"../types\";\nimport type { ActionCountsType, PlayerIndexedType } from \"./common\";\nimport { getSinglesPlayerPermutationsFromSettings, State } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\n// Frame pattern that indicates a dash dance turn was executed\nconst dashDanceAnimations = [State.DASH, State.TURN, State.DASH];\n\ntype PlayerActionState = {\n  playerCounts: ActionCountsType;\n  animations: number[];\n  actionFrameCounters: number[];\n};\n\nexport class ActionsComputer implements StatComputer<ActionCountsType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, PlayerActionState>();\n\n  public setup(settings: GameStartType): void {\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.playerPermutations.forEach((indices) => {\n      const playerCounts: ActionCountsType = {\n        playerIndex: indices.playerIndex,\n        wavedashCount: 0,\n        wavelandCount: 0,\n        airDodgeCount: 0,\n        dashDanceCount: 0,\n        spotDodgeCount: 0,\n        ledgegrabCount: 0,\n        rollCount: 0,\n        lCancelCount: {\n          success: 0,\n          fail: 0,\n        },\n        attackCount: {\n          jab1: 0,\n          jab2: 0,\n          jab3: 0,\n          jabm: 0,\n          dash: 0,\n          ftilt: 0,\n          utilt: 0,\n          dtilt: 0,\n          fsmash: 0,\n          usmash: 0,\n          dsmash: 0,\n          nair: 0,\n          fair: 0,\n          bair: 0,\n          uair: 0,\n          dair: 0,\n        },\n        grabCount: {\n          success: 0,\n          fail: 0,\n        },\n        throwCount: {\n          up: 0,\n          forward: 0,\n          back: 0,\n          down: 0,\n        },\n        groundTechCount: {\n          // tech away/in are in reference to the opponents position and not the stage\n          away: 0,\n          in: 0,\n          neutral: 0,\n          fail: 0,\n        },\n        wallTechCount: {\n          success: 0,\n          fail: 0,\n        },\n      };\n      const playerState: PlayerActionState = {\n        playerCounts: playerCounts,\n        animations: [],\n        actionFrameCounters: [],\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleActionCompute(state, indices, frame);\n      }\n    });\n  }\n\n  public fetch(): ActionCountsType[] {\n    return Array.from(this.state.values()).map((val) => val.playerCounts);\n  }\n}\n\nfunction isMissGroundTech(animation: State): boolean {\n  return animation === State.TECH_MISS_DOWN || animation === State.TECH_MISS_UP;\n}\n\nfunction isRolling(animation: State): boolean {\n  return animation === State.ROLL_BACKWARD || animation === State.ROLL_FORWARD;\n}\n\nfunction isGrabAction(animation: State): boolean {\n  // Includes Grab pull, wait, pummel, and throws\n  return animation > State.GRAB && animation <= State.THROW_DOWN && animation !== State.DASH_GRAB;\n}\n\nfunction isGrabbing(animation: State): boolean {\n  return animation === State.GRAB || animation === State.DASH_GRAB;\n}\n\nfunction isAerialAttack(animation: State): boolean {\n  return animation >= State.AERIAL_ATTACK_START && animation <= State.AERIAL_ATTACK_END;\n}\n\nfunction isForwardTilt(animation: State): boolean {\n  return animation >= State.ATTACK_FTILT_START && animation <= State.ATTACK_FTILT_END;\n}\n\nfunction isForwardSmash(animation: State): boolean {\n  return animation >= State.ATTACK_FSMASH_START && animation <= State.ATTACK_FSMASH_END;\n}\n\nfunction handleActionCompute(state: PlayerActionState, indices: PlayerIndexedType, frame: FrameEntryType): void {\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n  const incrementCount = (field: string, condition: boolean): void => {\n    if (!condition) {\n      return;\n    }\n\n    const current: number = get(state.playerCounts, field, 0);\n    set(state.playerCounts, field, current + 1);\n  };\n\n  // Manage animation state\n  const currentAnimation = playerFrame.actionStateId!;\n  state.animations.push(currentAnimation);\n  const currentFrameCounter = playerFrame.actionStateCounter!;\n  state.actionFrameCounters.push(currentFrameCounter);\n\n  // Grab last 3 frames\n  const last3Frames = state.animations.slice(-3);\n  const prevAnimation = last3Frames[last3Frames.length - 2] as number;\n  const prevFrameCounter = state.actionFrameCounters[state.actionFrameCounters.length - 2] as number;\n\n  // New action if new animation or frame counter goes back down (repeated action)\n  const isNewAction = currentAnimation !== prevAnimation || prevFrameCounter > currentFrameCounter;\n  if (!isNewAction) {\n    return;\n  }\n\n  // Increment counts based on conditions\n  const didDashDance = isEqual(last3Frames, dashDanceAnimations);\n  incrementCount(\"dashDanceCount\", didDashDance);\n\n  incrementCount(\"rollCount\", isRolling(currentAnimation));\n  incrementCount(\"spotDodgeCount\", currentAnimation === State.SPOT_DODGE);\n  incrementCount(\"airDodgeCount\", currentAnimation === State.AIR_DODGE);\n  incrementCount(\"ledgegrabCount\", currentAnimation === State.CLIFF_CATCH);\n\n  // Grabs\n  incrementCount(\"grabCount.success\", isGrabbing(prevAnimation) && isGrabAction(currentAnimation));\n  incrementCount(\"grabCount.fail\", isGrabbing(prevAnimation) && !isGrabAction(currentAnimation));\n  if (currentAnimation === State.DASH_GRAB && prevAnimation === State.ATTACK_DASH) {\n    state.playerCounts.attackCount.dash -= 1; // subtract from dash attack if boost grab\n  }\n\n  // Basic attacks\n  incrementCount(\"attackCount.jab1\", currentAnimation === State.ATTACK_JAB1);\n  incrementCount(\"attackCount.jab2\", currentAnimation === State.ATTACK_JAB2);\n  incrementCount(\"attackCount.jab3\", currentAnimation === State.ATTACK_JAB3);\n  incrementCount(\"attackCount.jabm\", currentAnimation === State.ATTACK_JABM);\n  incrementCount(\"attackCount.dash\", currentAnimation === State.ATTACK_DASH);\n  incrementCount(\"attackCount.ftilt\", isForwardTilt(currentAnimation));\n  incrementCount(\"attackCount.utilt\", currentAnimation === State.ATTACK_UTILT);\n  incrementCount(\"attackCount.dtilt\", currentAnimation === State.ATTACK_DTILT);\n  incrementCount(\"attackCount.fsmash\", isForwardSmash(currentAnimation));\n  incrementCount(\"attackCount.usmash\", currentAnimation === State.ATTACK_USMASH);\n  incrementCount(\"attackCount.dsmash\", currentAnimation === State.ATTACK_DSMASH);\n  incrementCount(\"attackCount.nair\", currentAnimation === State.AERIAL_NAIR);\n  incrementCount(\"attackCount.fair\", currentAnimation === State.AERIAL_FAIR);\n  incrementCount(\"attackCount.bair\", currentAnimation === State.AERIAL_BAIR);\n  incrementCount(\"attackCount.uair\", currentAnimation === State.AERIAL_UAIR);\n  incrementCount(\"attackCount.dair\", currentAnimation === State.AERIAL_DAIR);\n\n  // GnW is weird and has unique IDs for some moves\n  if (playerFrame.internalCharacterId === 0x18) {\n    incrementCount(\"attackCount.jab1\", currentAnimation === State.GNW_JAB1);\n    incrementCount(\"attackCount.jabm\", currentAnimation === State.GNW_JABM);\n    incrementCount(\"attackCount.dtilt\", currentAnimation === State.GNW_DTILT);\n    incrementCount(\"attackCount.fsmash\", currentAnimation === State.GNW_FSMASH);\n    incrementCount(\"attackCount.nair\", currentAnimation === State.GNW_NAIR);\n    incrementCount(\"attackCount.bair\", currentAnimation === State.GNW_BAIR);\n    incrementCount(\"attackCount.uair\", currentAnimation === State.GNW_UAIR);\n  }\n\n  // Peach is also weird and has a unique ID for her fsmash\n  // FSMASH1 = Golf Club, FSMASH2 = Frying Pan, FSMASH3 = Tennis Racket\n  if (playerFrame.internalCharacterId === 0x09) {\n    incrementCount(\"attackCount.fsmash\", currentAnimation === State.PEACH_FSMASH1);\n    incrementCount(\"attackCount.fsmash\", currentAnimation === State.PEACH_FSMASH2);\n    incrementCount(\"attackCount.fsmash\", currentAnimation === State.PEACH_FSMASH3);\n  }\n\n  // Throws\n  incrementCount(\"throwCount.up\", currentAnimation === State.THROW_UP);\n  incrementCount(\"throwCount.forward\", currentAnimation === State.THROW_FORWARD);\n  incrementCount(\"throwCount.down\", currentAnimation === State.THROW_DOWN);\n  incrementCount(\"throwCount.back\", currentAnimation === State.THROW_BACK);\n\n  // Techs\n  const opponentDir = playerFrame.positionX! > opponentFrame.positionX! ? -1 : 1;\n  const facingOpponent = playerFrame.facingDirection === opponentDir;\n\n  incrementCount(\"groundTechCount.fail\", isMissGroundTech(currentAnimation));\n  incrementCount(\"groundTechCount.in\", currentAnimation === State.FORWARD_TECH && facingOpponent);\n  incrementCount(\"groundTechCount.in\", currentAnimation === State.BACKWARD_TECH && !facingOpponent);\n  incrementCount(\"groundTechCount.neutral\", currentAnimation === State.NEUTRAL_TECH);\n  incrementCount(\"groundTechCount.away\", currentAnimation === State.BACKWARD_TECH && facingOpponent);\n  incrementCount(\"groundTechCount.away\", currentAnimation === State.FORWARD_TECH && !facingOpponent);\n  incrementCount(\"wallTechCount.success\", currentAnimation === State.WALL_TECH);\n  incrementCount(\"wallTechCount.fail\", currentAnimation === State.MISSED_WALL_TECH);\n\n  if (isAerialAttack(currentAnimation)) {\n    incrementCount(\"lCancelCount.success\", playerFrame.lCancelStatus === 1);\n    incrementCount(\"lCancelCount.fail\", playerFrame.lCancelStatus === 2);\n  }\n\n  // Handles wavedash detection (and waveland)\n  handleActionWavedash(state.playerCounts, state.animations);\n}\n\nfunction handleActionWavedash(counts: ActionCountsType, animations: State[]): void {\n  const currentAnimation = last(animations);\n  const prevAnimation = animations[animations.length - 2] as number;\n\n  const isSpecialLanding = currentAnimation === State.LANDING_FALL_SPECIAL;\n  const isAcceptablePrevious = isWavedashInitiationAnimation(prevAnimation);\n  const isPossibleWavedash = isSpecialLanding && isAcceptablePrevious;\n\n  if (!isPossibleWavedash) {\n    return;\n  }\n\n  // Here we special landed, it might be a wavedash, let's check\n  // We grab the last 8 frames here because that should be enough time to execute a\n  // wavedash. This number could be tweaked if we find false negatives\n  const recentFrames = animations.slice(-8);\n  const recentAnimations = keyBy(recentFrames, (animation) => animation);\n\n  if (size(recentAnimations) === 2 && recentAnimations[State.AIR_DODGE]) {\n    // If the only other animation is air dodge, this might be really late to the point\n    // where it was actually an air dodge. Air dodge animation is really long\n    return;\n  }\n\n  if (recentAnimations[State.AIR_DODGE]) {\n    // If one of the recent animations was an air dodge, let's remove that from the\n    // air dodge counter, we don't want to count air dodges used to wavedash/land\n    counts.airDodgeCount -= 1;\n  }\n\n  if (recentAnimations[State.ACTION_KNEE_BEND]) {\n    // If a jump was started recently, we will consider this a wavedash\n    counts.wavedashCount += 1;\n  } else {\n    // If there was no jump recently, this is a waveland\n    counts.wavelandCount += 1;\n  }\n}\n\nfunction isWavedashInitiationAnimation(animation: State): boolean {\n  if (animation === State.AIR_DODGE) {\n    return true;\n  }\n\n  const isAboveMin = animation >= State.CONTROLLED_JUMP_START;\n  const isBelowMax = animation <= State.CONTROLLED_JUMP_END;\n  return isAboveMin && isBelowMax;\n}\n","import { EventEmitter } from \"events\";\nimport last from \"lodash/last\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ComboType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isDead,\n  isDown,\n  isGrabbed,\n  isTeching,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nexport enum ComboEvent {\n  COMBO_START = \"COMBO_START\",\n  COMBO_EXTEND = \"COMBO_EXTEND\",\n  COMBO_END = \"COMBO_END\",\n}\n\ntype ComboState = {\n  combo: ComboType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n  event: ComboEvent | null;\n};\n\nexport class ComboComputer extends EventEmitter implements StatComputer<ComboType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, ComboState>();\n  private combos = new Array<ComboType>();\n  private settings: GameStartType | null = null;\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.settings = settings;\n    this.state = new Map();\n    this.combos = [];\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: ComboState = {\n        combo: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n        event: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleComboCompute(allFrames, state, indices, frame, this.combos);\n\n        // Emit an event for the new combo\n        if (state.event !== null) {\n          this.emit(state.event, {\n            combo: last(this.combos),\n            settings: this.settings,\n          });\n          state.event = null;\n        }\n      }\n    });\n  }\n\n  public fetch(): ComboType[] {\n    return this.combos;\n  }\n}\n\nfunction handleComboCompute(\n  frames: FramesType,\n  state: ComboState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  combos: ComboType[],\n): void {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a combo or count the moves for the existing combo\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    let comboStarted = false;\n    if (!state.combo) {\n      state.combo = {\n        playerIndex: indices.opponentIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        lastHitBy: indices.playerIndex,\n      };\n\n      combos.push(state.combo);\n\n      // Track whether this is a new combo or not\n      comboStarted = true;\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.combo.moves.push(state.move);\n\n        // Make sure we don't overwrite the START event\n        if (!comboStarted) {\n          state.event = ComboEvent.COMBO_EXTEND;\n        }\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n\n    if (comboStarted) {\n      state.event = ComboEvent.COMBO_START;\n    }\n  }\n\n  if (!state.combo) {\n    // The rest of the function handles combo termination logic, so if we don't\n    // have a combo started, there is no need to continue\n    return;\n  }\n\n  const opntIsTeching = isTeching(oppActionStateId);\n  const opntIsDowned = isDown(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n  const opntIsDying = isDead(oppActionStateId);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.combo.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed || opntIsTeching || opntIsDowned || opntIsDying) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  } else {\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.combo.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - combo resets on time\n  if (state.resetCounter > Timers.COMBO_STRING_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If combo should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.combo.endFrame = playerFrame.frame;\n    state.combo.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n    state.event = ComboEvent.COMBO_END;\n\n    state.combo = null;\n    state.move = null;\n  }\n}\n","export enum Command {\n  SPLIT_MESSAGE = 0x10,\n  MESSAGE_SIZES = 0x35,\n  GAME_START = 0x36,\n  PRE_FRAME_UPDATE = 0x37,\n  POST_FRAME_UPDATE = 0x38,\n  GAME_END = 0x39,\n  FRAME_START = 0x3a,\n  ITEM_UPDATE = 0x3b,\n  FRAME_BOOKEND = 0x3c,\n  GECKO_LIST = 0x3d,\n}\n\nexport type PlayerType = {\n  playerIndex: number;\n  port: number;\n  characterId: number | null;\n  type: number | null;\n  startStocks: number | null;\n  characterColor: number | null;\n  teamShade: number | null;\n  handicap: number | null;\n  teamId: number | null;\n  staminaMode: boolean | null;\n  silentCharacter: boolean | null;\n  invisible: boolean | null;\n  lowGravity: boolean | null;\n  blackStockIcon: boolean | null;\n  metal: boolean | null;\n  startOnAngelPlatform: boolean | null;\n  rumbleEnabled: boolean | null;\n  cpuLevel: number | null;\n  offenseRatio: number | null;\n  defenseRatio: number | null;\n  modelScale: number | null;\n  controllerFix: string | null;\n  nametag: string | null;\n  displayName: string;\n  connectCode: string;\n  userId: string;\n};\n\nexport enum GameMode {\n  VS = 0x02,\n  ONLINE = 0x08,\n  TARGET_TEST = 0x0f,\n  HOME_RUN_CONTEST = 0x20,\n}\n\nexport enum Language {\n  JAPANESE = 0,\n  ENGLISH = 1,\n}\n\nexport type GameStartType = {\n  slpVersion: string | null;\n  timerType: TimerType | null;\n  inGameMode: number | null;\n  friendlyFireEnabled: boolean | null;\n  isTeams: boolean | null;\n  stageId: number | null;\n  startingTimerSeconds: number | null;\n  itemSpawnBehavior: ItemSpawnType | null;\n  enabledItems: number | null;\n  players: PlayerType[];\n  scene: number | null;\n  gameMode: GameMode | null;\n  language: Language | null;\n  gameInfoBlock: GameInfoType | null;\n  randomSeed: number | null;\n  isPAL: boolean | null;\n  isFrozenPS: boolean | null;\n  matchInfo: MatchInfo | null;\n};\n\ntype MatchInfo = {\n  matchId: string | null;\n  gameNumber: number | null;\n  tiebreakerNumber: number | null;\n};\n\nexport type FrameStartType = {\n  frame: number | null;\n  seed: number | null;\n  sceneFrameCounter: number | null;\n};\n\nexport type GameInfoType = {\n  gameBitfield1: number | null;\n  gameBitfield2: number | null;\n  gameBitfield3: number | null;\n  gameBitfield4: number | null;\n  bombRainEnabled: boolean | null;\n  selfDestructScoreValue: number | null;\n  itemSpawnBitfield1: number | null;\n  itemSpawnBitfield2: number | null;\n  itemSpawnBitfield3: number | null;\n  itemSpawnBitfield4: number | null;\n  itemSpawnBitfield5: number | null;\n  damageRatio: number | null;\n};\n\nexport enum TimerType {\n  NONE = 0b00,\n  DECREASING = 0b10,\n  INCREASING = 0b11,\n}\n\nexport enum ItemSpawnType {\n  OFF = 0xff,\n  VERY_LOW = 0x00,\n  LOW = 0x01,\n  MEDIUM = 0x02,\n  HIGH = 0x03,\n  VERY_HIGH = 0x04,\n}\n\nexport enum EnabledItemType {\n  METAL_BOX = 2 ** 0,\n  CLOAKING_DEVICE = 2 ** 1,\n  POKEBALL = 2 ** 2,\n  // Bits 4 through 8 of item bitfield 1 are unknown\n  UNKNOWN_ITEM_BIT_4 = 2 ** 3,\n  UNKNOWN_ITEM_BIT_5 = 2 ** 4,\n  UNKNOWN_ITEM_BIT_6 = 2 ** 5,\n  UNKNOWN_ITEM_BIT_7 = 2 ** 6,\n  UNKNOWN_ITEM_BIT_8 = 2 ** 7,\n  FAN = 2 ** 8,\n  FIRE_FLOWER = 2 ** 9,\n  SUPER_MUSHROOM = 2 ** 10,\n  POISON_MUSHROOM = 2 ** 11,\n  HAMMER = 2 ** 12,\n  WARP_STAR = 2 ** 13,\n  SCREW_ATTACK = 2 ** 14,\n  BUNNY_HOOD = 2 ** 15,\n  RAY_GUN = 2 ** 16,\n  FREEZIE = 2 ** 17,\n  FOOD = 2 ** 18,\n  MOTION_SENSOR_BOMB = 2 ** 19,\n  FLIPPER = 2 ** 20,\n  SUPER_SCOPE = 2 ** 21,\n  STAR_ROD = 2 ** 22,\n  LIPS_STICK = 2 ** 23,\n  HEART_CONTAINER = 2 ** 24,\n  MAXIM_TOMATO = 2 ** 25,\n  STARMAN = 2 ** 26,\n  HOME_RUN_BAT = 2 ** 27,\n  BEAM_SWORD = 2 ** 28,\n  PARASOL = 2 ** 29,\n  GREEN_SHELL = 2 ** 30,\n  RED_SHELL = 2 ** 31,\n  CAPSULE = 2 ** 32,\n  BOX = 2 ** 33,\n  BARREL = 2 ** 34,\n  EGG = 2 ** 35,\n  PARTY_BALL = 2 ** 36,\n  BARREL_CANNON = 2 ** 37,\n  BOMB_OMB = 2 ** 38,\n  MR_SATURN = 2 ** 39,\n}\n\nexport type PreFrameUpdateType = {\n  frame: number | null;\n  playerIndex: number | null;\n  isFollower: boolean | null;\n  seed: number | null;\n  actionStateId: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  facingDirection: number | null;\n  joystickX: number | null;\n  joystickY: number | null;\n  cStickX: number | null;\n  cStickY: number | null;\n  trigger: number | null;\n  buttons: number | null;\n  physicalButtons: number | null;\n  physicalLTrigger: number | null;\n  physicalRTrigger: number | null;\n  rawJoystickX: number | null;\n  percent: number | null;\n};\n\nexport type PostFrameUpdateType = {\n  frame: number | null;\n  playerIndex: number | null;\n  isFollower: boolean | null;\n  internalCharacterId: number | null;\n  actionStateId: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  facingDirection: number | null;\n  percent: number | null;\n  shieldSize: number | null;\n  lastAttackLanded: number | null;\n  currentComboCount: number | null;\n  lastHitBy: number | null;\n  stocksRemaining: number | null;\n  actionStateCounter: number | null;\n  miscActionState: number | null;\n  isAirborne: boolean | null;\n  lastGroundId: number | null;\n  jumpsRemaining: number | null;\n  lCancelStatus: number | null;\n  hurtboxCollisionState: number | null;\n  selfInducedSpeeds: SelfInducedSpeedsType | null;\n  hitlagRemaining: number | null;\n  animationIndex: number | null;\n  instanceHitBy: number | null;\n  instanceId: number | null;\n};\n\nexport type SelfInducedSpeedsType = {\n  airX: number | null;\n  y: number | null;\n  attackX: number | null;\n  attackY: number | null;\n  groundX: number | null;\n};\n\nexport type ItemUpdateType = {\n  frame: number | null;\n  typeId: number | null;\n  state: number | null;\n  facingDirection: number | null;\n  velocityX: number | null;\n  velocityY: number | null;\n  positionX: number | null;\n  positionY: number | null;\n  damageTaken: number | null;\n  expirationTimer: number | null;\n  spawnId: number | null;\n  missileType: number | null;\n  turnipFace: number | null;\n  chargeShotLaunched: number | null;\n  chargePower: number | null;\n  owner: number | null;\n  instanceId: number | null;\n};\n\nexport type FrameBookendType = {\n  frame: number | null;\n  latestFinalizedFrame: number | null;\n};\n\nexport enum GameEndMethod {\n  UNRESOLVED = 0,\n  RESOLVED = 3,\n  // The following options are only returned in version 2.0.0 onwards\n  TIME = 1,\n  GAME = 2,\n  NO_CONTEST = 7,\n}\n\nexport type GameEndType = {\n  gameEndMethod: GameEndMethod | null;\n  lrasInitiatorIndex: number | null;\n  placements: PlacementType[];\n};\n\nexport type PlacementType = {\n  playerIndex: number;\n  position: number | null;\n};\n\nexport type GeckoListType = {\n  codes: GeckoCodeType[];\n  contents: Uint8Array;\n};\n\nexport type GeckoCodeType = {\n  type: number | null;\n  address: number | null;\n  contents: Uint8Array;\n};\n\nexport type MetadataType = {\n  startAt?: string | null;\n  playedOn?: string | null;\n  lastFrame?: number | null;\n  players?: {\n    [playerIndex: number]: {\n      characters: {\n        [internalCharacterId: number]: number;\n      };\n      names?: {\n        netplay?: string | null;\n        code?: string | null;\n      };\n    };\n  } | null;\n  consoleNick?: string | null;\n};\n\nexport type EventPayloadTypes =\n  | GameStartType\n  | FrameStartType\n  | PreFrameUpdateType\n  | PostFrameUpdateType\n  | ItemUpdateType\n  | FrameBookendType\n  | GameEndType\n  | GeckoListType;\n\nexport type EventCallbackFunc = (\n  command: Command,\n  payload?: EventPayloadTypes | null,\n  buffer?: Uint8Array | null,\n) => boolean;\n\nexport type FrameEntryType = {\n  frame: number;\n  start?: FrameStartType;\n  players: {\n    [playerIndex: number]: {\n      pre: PreFrameUpdateType;\n      post: PostFrameUpdateType;\n    } | null;\n  };\n  followers: {\n    [playerIndex: number]: {\n      pre: PreFrameUpdateType;\n      post: PostFrameUpdateType;\n    } | null;\n  };\n  items?: ItemUpdateType[];\n};\n\nexport enum Frames {\n  FIRST = -123,\n  FIRST_PLAYABLE = -39,\n}\n\nexport type FramesType = {\n  [frameIndex: number]: FrameEntryType;\n};\n\nexport type RollbackFramesType = {\n  [frameIndex: number]: FrameEntryType[];\n};\n\nexport type RollbackFrames = {\n  frames: RollbackFramesType;\n  count: number;\n  lengths: number[];\n};\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\nimport type { PlayerIndexedType } from \"./common\";\nimport { getSinglesPlayerPermutationsFromSettings } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nenum JoystickRegion {\n  DZ = 0,\n  NE = 1,\n  SE = 2,\n  SW = 3,\n  NW = 4,\n  N = 5,\n  E = 6,\n  S = 7,\n  W = 8,\n}\n\nexport type PlayerInput = {\n  playerIndex: number;\n  opponentIndex: number;\n  inputCount: number;\n  joystickInputCount: number;\n  cstickInputCount: number;\n  buttonInputCount: number;\n  triggerInputCount: number;\n};\n\nexport class InputComputer implements StatComputer<PlayerInput[]> {\n  private state = new Map<PlayerIndexedType, PlayerInput>();\n  private playerPermutations = new Array<PlayerIndexedType>();\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerInput = {\n        playerIndex: indices.playerIndex,\n        opponentIndex: indices.opponentIndex,\n        inputCount: 0,\n        joystickInputCount: 0,\n        cstickInputCount: 0,\n        buttonInputCount: 0,\n        triggerInputCount: 0,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleInputCompute(allFrames, state, indices, frame);\n      }\n    });\n  }\n\n  public fetch(): PlayerInput[] {\n    return Array.from(this.state.values());\n  }\n}\n\nfunction handleInputCompute(\n  frames: FramesType,\n  state: PlayerInput,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n): void {\n  const playerFrame = frame.players[indices.playerIndex]!.pre;\n  const currentFrameNumber = playerFrame.frame!;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber]!.players[indices.playerIndex]!.pre : null;\n\n  if (currentFrameNumber < Frames.FIRST_PLAYABLE || !prevPlayerFrame) {\n    // Don't count inputs until the game actually starts\n    return;\n  }\n\n  // First count the number of buttons that go from 0 to 1\n  // Increment action count by amount of button presses\n  const invertedPreviousButtons = ~prevPlayerFrame.physicalButtons!;\n  const currentButtons = playerFrame.physicalButtons!;\n  const buttonChanges = invertedPreviousButtons & currentButtons & 0xfff;\n  const newInputsPressed = countSetBits(buttonChanges);\n  state.inputCount += newInputsPressed;\n  state.buttonInputCount += newInputsPressed;\n\n  // Increment action count when sticks change from one region to another.\n  // Don't increment when stick returns to deadzone\n  const prevAnalogRegion = getJoystickRegion(prevPlayerFrame.joystickX!, prevPlayerFrame.joystickY!);\n  const currentAnalogRegion = getJoystickRegion(playerFrame.joystickX!, playerFrame.joystickY!);\n  if (prevAnalogRegion !== currentAnalogRegion && currentAnalogRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.joystickInputCount += 1;\n  }\n\n  // Do the same for c-stick\n  const prevCstickRegion = getJoystickRegion(prevPlayerFrame.cStickX!, prevPlayerFrame.cStickY!);\n  const currentCstickRegion = getJoystickRegion(playerFrame.cStickX!, playerFrame.cStickY!);\n  if (prevCstickRegion !== currentCstickRegion && currentCstickRegion !== JoystickRegion.DZ) {\n    state.inputCount += 1;\n    state.cstickInputCount += 1;\n  }\n\n  // Increment action on analog trigger... I'm not sure when. This needs revision\n  // Currently will update input count when the button gets pressed past 0.3\n  // Changes from hard shield to light shield should probably count as inputs but\n  // are not counted here\n  if (prevPlayerFrame.physicalLTrigger! < 0.3 && playerFrame.physicalLTrigger! >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n  if (prevPlayerFrame.physicalRTrigger! < 0.3 && playerFrame.physicalRTrigger! >= 0.3) {\n    state.inputCount += 1;\n    state.triggerInputCount += 1;\n  }\n}\n\nfunction countSetBits(x: number): number {\n  // This function solves the Hamming Weight problem. Effectively it counts the number of\n  // bits in the input that are set to 1\n  // This implementation is supposedly very efficient when most bits are zero.\n  // Found: https://en.wikipedia.org/wiki/Hamming_weight#Efficient_implementation\n  let bits = x;\n\n  let count;\n  for (count = 0; bits; count += 1) {\n    bits &= bits - 1;\n  }\n  return count;\n}\n\nfunction getJoystickRegion(x: number, y: number): JoystickRegion {\n  let region = JoystickRegion.DZ;\n\n  if (x >= 0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NE;\n  } else if (x >= 0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SE;\n  } else if (x <= -0.2875 && y <= -0.2875) {\n    region = JoystickRegion.SW;\n  } else if (x <= -0.2875 && y >= 0.2875) {\n    region = JoystickRegion.NW;\n  } else if (y >= 0.2875) {\n    region = JoystickRegion.N;\n  } else if (x >= 0.2875) {\n    region = JoystickRegion.E;\n  } else if (y <= -0.2875) {\n    region = JoystickRegion.S;\n  } else if (x <= -0.2875) {\n    region = JoystickRegion.W;\n  }\n\n  return region;\n}\n","import { EventEmitter } from \"events\";\nimport filter from \"lodash/filter\";\nimport get from \"lodash/get\";\nimport groupBy from \"lodash/groupBy\";\nimport last from \"lodash/last\";\nimport orderBy from \"lodash/orderBy\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ConversionType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isGrabbed,\n  isInControl,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ntype PlayerConversionState = {\n  conversion: ConversionType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n};\n\ntype MetadataType = {\n  lastEndFrameByOppIdx: {\n    [oppIdx: number]: number;\n  };\n};\n\nexport class ConversionComputer extends EventEmitter implements StatComputer<ConversionType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private conversions = new Array<ConversionType>();\n  private state = new Map<PlayerIndexedType, PlayerConversionState>();\n  private metadata: MetadataType;\n  private settings: GameStartType | null = null;\n\n  public constructor() {\n    super();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n  }\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.conversions = [];\n    this.state = new Map();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n    this.settings = settings;\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerConversionState = {\n        conversion: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        const terminated = handleConversionCompute(allFrames, state, indices, frame, this.conversions);\n        if (terminated) {\n          this.emit(\"CONVERSION\", {\n            combo: last(this.conversions),\n            settings: this.settings,\n          });\n        }\n      }\n    });\n  }\n\n  public fetch(): ConversionType[] {\n    this._populateConversionTypes();\n    return this.conversions;\n  }\n\n  private _populateConversionTypes(): void {\n    // Post-processing step: set the openingTypes\n    const conversionsToHandle = filter(this.conversions, (conversion) => {\n      return conversion.openingType === \"unknown\";\n    });\n\n    // Group new conversions by startTime and sort\n    const groupedConversions = groupBy(conversionsToHandle, \"startFrame\");\n    const sortedConversions = orderBy(groupedConversions, (conversions) => get(conversions, [0, \"startFrame\"]));\n\n    // Set the opening types on the conversions we need to handle\n    sortedConversions.forEach((conversions) => {\n      const isTrade = conversions.length >= 2;\n      conversions.forEach((conversion) => {\n        // Set end frame for this conversion\n        this.metadata.lastEndFrameByOppIdx[conversion.playerIndex] = conversion.endFrame!;\n\n        if (isTrade) {\n          // If trade, just short-circuit\n          conversion.openingType = \"trade\";\n          return;\n        }\n\n        // If not trade, check the opponent endFrame\n        const lastMove = last(conversion.moves);\n        const oppEndFrame =\n          this.metadata.lastEndFrameByOppIdx[lastMove ? lastMove.playerIndex : conversion.playerIndex];\n        const isCounterAttack = oppEndFrame && oppEndFrame > conversion.startFrame;\n        conversion.openingType = isCounterAttack ? \"counter-attack\" : \"neutral-win\";\n      });\n    });\n  }\n}\n\nfunction handleConversionCompute(\n  frames: FramesType,\n  state: PlayerConversionState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  conversions: ConversionType[],\n): boolean {\n  const currentFrameNumber = frame.frame;\n  const playerFrame: PostFrameUpdateType = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a conversion or\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    if (!state.conversion) {\n      state.conversion = {\n        playerIndex: indices.opponentIndex,\n        lastHitBy: indices.playerIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        openingType: \"unknown\", // Will be updated later\n      };\n\n      conversions.push(state.conversion);\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.conversion.moves.push(state.move);\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n  }\n\n  if (!state.conversion) {\n    // The rest of the function handles conversion termination logic, so if we don't\n    // have a conversion started, there is no need to continue\n    return false;\n  }\n\n  const opntInControl = isInControl(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.conversion.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  }\n\n  const shouldStartResetCounter = state.resetCounter === 0 && opntInControl;\n  const shouldContinueResetCounter = state.resetCounter > 0;\n  if (shouldStartResetCounter || shouldContinueResetCounter) {\n    // This will increment the reset timer under the following conditions:\n    // 1) if we were punishing opponent but they have now entered an actionable state\n    // 2) if counter has already started counting meaning opponent has entered actionable state\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.conversion.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - conversion resets on time\n  if (state.resetCounter > Timers.PUNISH_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If conversion should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.conversion.endFrame = playerFrame.frame;\n    state.conversion.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n\n    state.conversion = null;\n    state.move = null;\n  }\n\n  return shouldTerminate;\n}\n","import first from \"lodash/first\";\nimport flatten from \"lodash/flatten\";\nimport get from \"lodash/get\";\nimport groupBy from \"lodash/groupBy\";\nimport keyBy from \"lodash/keyBy\";\nimport last from \"lodash/last\";\nimport mapValues from \"lodash/mapValues\";\nimport zip from \"lodash/zip\";\n\nimport type { GameStartType } from \"../types\";\nimport type { ConversionType, InputCountsType, OverallType, RatioType } from \"./common\";\nimport type { PlayerInput } from \"./inputs\";\n\ntype ConversionsByPlayerByOpening = {\n  [playerIndex: string]: {\n    [openingType: string]: ConversionType[];\n  };\n};\n\nexport function generateOverallStats({\n  settings,\n  inputs,\n  conversions,\n  playableFrameCount,\n}: {\n  settings: GameStartType;\n  inputs: PlayerInput[];\n  conversions: ConversionType[];\n  playableFrameCount: number;\n}): OverallType[] {\n  const inputsByPlayer = keyBy(inputs, \"playerIndex\");\n  const originalConversions = conversions;\n  const conversionsByPlayer = groupBy(conversions, (conv) => conv.moves[0]?.playerIndex);\n  const conversionsByPlayerByOpening: ConversionsByPlayerByOpening = mapValues(conversionsByPlayer, (conversions) =>\n    groupBy(conversions, \"openingType\"),\n  );\n\n  const gameMinutes = playableFrameCount / 3600;\n\n  const overall = settings.players.map((player) => {\n    const playerIndex = player.playerIndex;\n\n    const playerInputs = get(inputsByPlayer, playerIndex) || {};\n    const inputCounts: InputCountsType = {\n      buttons: get(playerInputs, \"buttonInputCount\"),\n      triggers: get(playerInputs, \"triggerInputCount\"),\n      cstick: get(playerInputs, \"cstickInputCount\"),\n      joystick: get(playerInputs, \"joystickInputCount\"),\n      total: get(playerInputs, \"inputCount\"),\n    };\n    // const conversions = get(conversionsByPlayer, playerIndex) || [];\n    // const successfulConversions = conversions.filter((conversion) => conversion.moves.length > 1);\n    let conversionCount = 0;\n    let successfulConversionCount = 0;\n\n    const opponentIndices = settings.players\n      .filter((opp) => {\n        // We want players which aren't ourselves\n        if (opp.playerIndex === playerIndex) {\n          return false;\n        }\n\n        // Make sure they're not on our team either\n        return !settings.isTeams || opp.teamId !== player.teamId;\n      })\n      .map((opp) => opp.playerIndex);\n\n    let totalDamage = 0;\n    let killCount = 0;\n\n    // These are the conversions that we did on our opponents\n    originalConversions\n      // Filter down to conversions of our opponent\n      .filter((conversion) => conversion.playerIndex !== playerIndex)\n      .forEach((conversion) => {\n        conversionCount++;\n\n        // We killed the opponent\n        if (conversion.didKill && conversion.lastHitBy === playerIndex) {\n          killCount += 1;\n        }\n        if (conversion.moves.length > 1 && conversion.moves[0]!.playerIndex === playerIndex) {\n          successfulConversionCount++;\n        }\n        conversion.moves.forEach((move) => {\n          if (move.playerIndex === playerIndex) {\n            totalDamage += move.damage;\n          }\n        });\n      });\n\n    return {\n      playerIndex: playerIndex,\n      inputCounts: inputCounts,\n      conversionCount: conversionCount,\n      totalDamage: totalDamage,\n      killCount: killCount,\n\n      successfulConversions: getRatio(successfulConversionCount, conversionCount),\n      inputsPerMinute: getRatio(inputCounts.total, gameMinutes),\n      digitalInputsPerMinute: getRatio(inputCounts.buttons, gameMinutes),\n      openingsPerKill: getRatio(conversionCount, killCount),\n      damagePerOpening: getRatio(totalDamage, conversionCount),\n      neutralWinRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"neutral-win\"),\n      counterHitRatio: getOpeningRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices, \"counter-attack\"),\n      beneficialTradeRatio: getBeneficialTradeRatio(conversionsByPlayerByOpening, playerIndex, opponentIndices),\n    };\n  });\n\n  return overall;\n}\n\nfunction getRatio(count: number, total: number): RatioType {\n  return {\n    count: count,\n    total: total,\n    ratio: total ? count / total : null,\n  };\n}\n\nfunction getOpeningRatio(\n  conversionsByPlayerByOpening: ConversionsByPlayerByOpening,\n  playerIndex: number,\n  opponentIndices: number[],\n  type: string,\n): RatioType {\n  const openings = get(conversionsByPlayerByOpening, [playerIndex, type]) || [];\n\n  const opponentOpenings = flatten(\n    opponentIndices.map((opponentIndex) => get(conversionsByPlayerByOpening, [opponentIndex, type]) || []),\n  );\n\n  return getRatio(openings.length, openings.length + opponentOpenings.length);\n}\n\nfunction getBeneficialTradeRatio(\n  conversionsByPlayerByOpening: ConversionsByPlayerByOpening,\n  playerIndex: number,\n  opponentIndices: number[],\n): RatioType {\n  const playerTrades = get(conversionsByPlayerByOpening, [playerIndex, \"trade\"]) || [];\n  const opponentTrades = flatten(\n    opponentIndices.map((opponentIndex) => get(conversionsByPlayerByOpening, [opponentIndex, \"trade\"]) || []),\n  );\n\n  const benefitsPlayer = [];\n\n  // Figure out which punishes benefited this player\n  const zippedTrades = zip(playerTrades, opponentTrades);\n  zippedTrades.forEach((conversionPair) => {\n    const playerConversion = first(conversionPair);\n    const opponentConversion = last(conversionPair);\n    if (playerConversion && opponentConversion) {\n      const playerDamage = playerConversion.currentPercent - playerConversion.startPercent;\n      const opponentDamage = opponentConversion.currentPercent - opponentConversion.startPercent;\n\n      if (playerConversion!.didKill && !opponentConversion!.didKill) {\n        benefitsPlayer.push(playerConversion);\n      } else if (playerDamage > opponentDamage) {\n        benefitsPlayer.push(playerConversion);\n      }\n    }\n  });\n\n  return getRatio(benefitsPlayer.length, playerTrades.length);\n}\n","import get from \"lodash/get\";\n\nimport type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\n\nexport interface StatComputer<T> {\n  setup(settings: GameStartType): void;\n  processFrame(newFrame: FrameEntryType, allFrames: FramesType): void;\n  fetch(): T;\n}\n\nexport type StatOptions = {\n  processOnTheFly: boolean;\n};\n\nconst defaultOptions: StatOptions = {\n  processOnTheFly: false,\n};\n\nexport class Stats {\n  private options: StatOptions;\n  private lastProcessedFrame: number | null = null;\n  private frames: FramesType = {};\n  private players: number[] = [];\n  private allComputers = new Array<StatComputer<unknown>>();\n\n  public constructor(options?: StatOptions) {\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n\n  /**\n   * Should reset the frames to their default values.\n   */\n  public setup(settings: GameStartType): void {\n    // Reset the frames since it's a new game\n    this.frames = {};\n    this.players = settings.players.map((v) => v.playerIndex);\n\n    // Forward the settings on to the individual stat computer\n    this.allComputers.forEach((comp) => comp.setup(settings));\n  }\n\n  public register(...computer: StatComputer<unknown>[]): void {\n    this.allComputers.push(...computer);\n  }\n\n  public process(): void {\n    if (this.players.length === 0) {\n      return;\n    }\n\n    let i = this.lastProcessedFrame !== null ? this.lastProcessedFrame + 1 : Frames.FIRST;\n    while (this.frames[i]) {\n      const frame = this.frames[i];\n      // Don't attempt to compute stats on frames that have not been fully received\n      if (!isCompletedFrame(this.players, frame)) {\n        return;\n      }\n      this.allComputers.forEach((comp) => comp.processFrame(frame, this.frames));\n      this.lastProcessedFrame = i;\n      i++;\n    }\n  }\n\n  public addFrame(frame: FrameEntryType): void {\n    this.frames[frame.frame] = frame;\n\n    if (this.options.processOnTheFly) {\n      this.process();\n    }\n  }\n}\n\nfunction isCompletedFrame(players: number[], frame?: FrameEntryType): frame is FrameEntryType {\n  if (!frame) {\n    return false;\n  }\n\n  // This function checks whether we have successfully received an entire frame.\n  // It is not perfect because it does not wait for follower frames. Fortunately,\n  // follower frames are not used for any stat calculations so this doesn't matter\n  // for our purposes.\n  for (const player of players) {\n    const playerPostFrame = get(frame, [\"players\", player, \"post\"]);\n    if (!playerPostFrame) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport type { PlayerIndexedType, StockType } from \"./common\";\nimport { didLoseStock, getSinglesPlayerPermutationsFromSettings, isDead } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ntype StockState = {\n  stock?: StockType | null;\n};\n\nexport class StockComputer implements StatComputer<StockType[]> {\n  private state = new Map<PlayerIndexedType, StockState>();\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private stocks = new Array<StockType>();\n\n  public setup(settings: GameStartType): void {\n    // Reset state\n    this.state = new Map();\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.stocks = [];\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: StockState = {\n        stock: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleStockCompute(allFrames, state, indices, frame, this.stocks);\n      }\n    });\n  }\n\n  public fetch(): StockType[] {\n    return this.stocks;\n  }\n}\n\nfunction handleStockCompute(\n  frames: FramesType,\n  state: StockState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  stocks: StockType[],\n): void {\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const currentFrameNumber = playerFrame.frame!;\n  const prevFrameNumber = currentFrameNumber - 1;\n  const prevPlayerFrame = frames[prevFrameNumber] ? frames[prevFrameNumber]!.players[indices.playerIndex]!.post : null;\n\n  // If there is currently no active stock, wait until the player is no longer spawning.\n  // Once the player is no longer spawning, start the stock\n  if (!state.stock) {\n    const isPlayerDead = isDead(playerFrame.actionStateId!);\n    if (isPlayerDead) {\n      return;\n    }\n\n    state.stock = {\n      playerIndex: indices.playerIndex,\n      startFrame: currentFrameNumber,\n      endFrame: null,\n      startPercent: 0,\n      endPercent: null,\n      currentPercent: 0,\n      count: playerFrame.stocksRemaining!,\n      deathAnimation: null,\n    };\n\n    stocks.push(state.stock);\n  } else if (prevPlayerFrame && didLoseStock(playerFrame, prevPlayerFrame)) {\n    state.stock.endFrame = playerFrame.frame;\n    state.stock.endPercent = prevPlayerFrame.percent ?? 0;\n    state.stock.deathAnimation = playerFrame.actionStateId;\n    state.stock = null;\n  } else {\n    state.stock.currentPercent = playerFrame.percent ?? 0;\n  }\n}\n","// Based on https://github.com/wilsonzlin/edgesearch/blob/d03816dd4b18d3d2eb6d08cb1ae14f96f046141d/demo/wiki/client/src/util/util.ts\n\n// Ensures value is not null or undefined.\n// != does no type validation so we don't need to explcitly check for undefined.\nexport function exists<T>(value: T | null | undefined): value is T {\n  return value != null;\n}\n","import type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames, GameMode } from \"../types\";\nimport { exists } from \"../utils/exists\";\nimport type { TargetBreakType } from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\n// The Target item's in-game ID\nconst TARGET_ITEM_TYPE_ID = 209;\n\nexport class TargetBreakComputer implements StatComputer<TargetBreakType[]> {\n  private targetBreaks = new Array<TargetBreakType>();\n  private isTargetTestGame = false;\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.targetBreaks = [];\n    this.isTargetTestGame = settings.gameMode === GameMode.TARGET_TEST;\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    if (!this.isTargetTestGame) {\n      return;\n    }\n\n    handleTargetBreak(allFrames, frame, this.targetBreaks);\n  }\n\n  public fetch(): TargetBreakType[] {\n    return this.targetBreaks;\n  }\n}\n\nfunction handleTargetBreak(frames: FramesType, frame: FrameEntryType, targetBreaks: TargetBreakType[]) {\n  const currentFrameNumber = frame.frame;\n  const prevFrameNumber = currentFrameNumber - 1;\n\n  // Add all targets on the first frame\n  if (currentFrameNumber === Frames.FIRST) {\n    const targets = frames[Frames.FIRST]?.items?.filter((item) => item.typeId === TARGET_ITEM_TYPE_ID) ?? [];\n\n    targets.forEach((target) => {\n      targetBreaks.push({\n        spawnId: target.spawnId as number,\n        frameDestroyed: null,\n        positionX: target.positionX as number,\n        positionY: target.positionY as number,\n      });\n    });\n  }\n\n  const currentTargets = frames[currentFrameNumber]?.items?.filter((item) => item.typeId === TARGET_ITEM_TYPE_ID) ?? [];\n  const previousTargets = frames[prevFrameNumber]?.items?.filter((item) => item.typeId === TARGET_ITEM_TYPE_ID) ?? [];\n\n  const currentTargetIds = currentTargets.map((item) => item.spawnId).filter(exists);\n  const previousTargetIds = previousTargets.map((item) => item.spawnId).filter(exists);\n\n  // Check if any targets were destroyed\n  const brokenTargetIds = previousTargetIds.filter((id) => !currentTargetIds.includes(id));\n  brokenTargetIds.forEach((id) => {\n    // Update the target break\n    const targetBreak = targetBreaks.find((targetBreak) => targetBreak.spawnId === id);\n    if (targetBreak) {\n      targetBreak.frameDestroyed = currentFrameNumber;\n    }\n  });\n}\n","import { decode, encode } from \"@shelacek/ubjson\";\n\nexport enum CommunicationType {\n  HANDSHAKE = 1,\n  REPLAY = 2,\n  KEEP_ALIVE = 3,\n}\n\nexport type CommunicationMessage = {\n  type: CommunicationType;\n  payload: {\n    cursor: Uint8Array;\n    clientToken: Uint8Array;\n    pos: Uint8Array;\n    nextPos: Uint8Array;\n    data: Uint8Array;\n    nick: string | null;\n    forcePos: boolean;\n    nintendontVersion: string | null;\n  };\n};\n\n// This class is responsible for handling the communication protocol between the Wii and the\n// desktop app\nexport class ConsoleCommunication {\n  private receiveBuf = Buffer.from([]);\n  private messages = new Array<CommunicationMessage>();\n\n  public receive(data: Buffer): void {\n    this.receiveBuf = Buffer.concat([this.receiveBuf, data]);\n\n    while (this.receiveBuf.length >= 4) {\n      // First get the size of the message we are expecting\n      const msgSize = this.receiveBuf.readUInt32BE(0);\n\n      if (this.receiveBuf.length < msgSize + 4) {\n        // If we haven't received all the data yet, let's wait for more\n        return;\n      }\n\n      // Here we have received all the data, so let's decode it\n      const ubjsonData = this.receiveBuf.slice(4, msgSize + 4);\n      this.messages.push(decode(ubjsonData));\n\n      // Remove the processed data from receiveBuf\n      this.receiveBuf = this.receiveBuf.slice(msgSize + 4);\n    }\n  }\n\n  public getReceiveBuffer(): Buffer {\n    return this.receiveBuf;\n  }\n\n  public getMessages(): Array<CommunicationMessage> {\n    const toReturn = this.messages;\n    this.messages = [];\n\n    return toReturn;\n  }\n\n  public genHandshakeOut(cursor: Uint8Array, clientToken: number, isRealtime = false): Buffer {\n    const clientTokenBuf = Buffer.from([0, 0, 0, 0]);\n    clientTokenBuf.writeUInt32BE(clientToken, 0);\n\n    const message = {\n      type: CommunicationType.HANDSHAKE,\n      payload: {\n        cursor: cursor,\n        clientToken: Uint8Array.from(clientTokenBuf), // TODO: Use real instance token\n        isRealtime: isRealtime,\n      },\n    };\n\n    const buf = encode(message, {\n      optimizeArrays: true,\n    });\n\n    const msg = Buffer.concat([Buffer.from([0, 0, 0, 0]), Buffer.from(buf)]);\n\n    msg.writeUInt32BE(buf.byteLength, 0);\n\n    return msg;\n  }\n}\n","import type { EventEmitter } from \"events\";\n\nexport enum ConnectionEvent {\n  CONNECT = \"connect\",\n  MESSAGE = \"message\",\n  HANDSHAKE = \"handshake\",\n  STATUS_CHANGE = \"statusChange\",\n  DATA = \"data\",\n  ERROR = \"error\",\n}\n\nexport enum ConnectionStatus {\n  DISCONNECTED = 0,\n  CONNECTING = 1,\n  CONNECTED = 2,\n  RECONNECT_WAIT = 3,\n}\n\nexport enum Ports {\n  DEFAULT = 51441,\n  LEGACY = 666,\n  RELAY_START = 53741,\n}\n\nexport type ConnectionDetails = {\n  consoleNick: string;\n  gameDataCursor: number | Uint8Array;\n  version: string;\n  clientToken?: number;\n};\n\nexport type ConnectionSettings = {\n  ipAddress: string;\n  port: number;\n};\n\nexport interface Connection extends EventEmitter {\n  getStatus(): ConnectionStatus;\n  getSettings(): ConnectionSettings;\n  getDetails(): ConnectionDetails;\n  connect(ip: string, port: number): void;\n  disconnect(): void;\n}\n","import { EventEmitter } from \"events\";\nimport inject from \"reconnect-core\";\n\nimport type { CommunicationMessage } from \"./communication\";\nimport { CommunicationType, ConsoleCommunication } from \"./communication\";\nimport type { Connection, ConnectionDetails, ConnectionSettings } from \"./types\";\nimport { ConnectionEvent, ConnectionStatus, Ports } from \"./types\";\n\nexport const NETWORK_MESSAGE = \"HELO\\0\";\n\nconst DEFAULT_CONNECTION_TIMEOUT_MS = 20000;\n\nenum CommunicationState {\n  INITIAL = \"initial\",\n  LEGACY = \"legacy\",\n  NORMAL = \"normal\",\n}\n\nconst defaultConnectionDetails: ConnectionDetails = {\n  consoleNick: \"unknown\",\n  gameDataCursor: Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0]),\n  version: \"\",\n  clientToken: 0,\n};\n\nconst consoleConnectionOptions = {\n  autoReconnect: true,\n};\n\nexport type ConsoleConnectionOptions = typeof consoleConnectionOptions;\n\n/**\n * Responsible for maintaining connection to a Slippi relay connection or Wii connection.\n * Events are emitted whenever data is received.\n *\n * Basic usage example:\n *\n * ```javascript\n * const { ConsoleConnection } = require(\"@slippi/slippi-js\");\n *\n * const connection = new ConsoleConnection();\n * connection.connect(\"localhost\", 667); // You should set these values appropriately\n *\n * connection.on(\"data\", (data) => {\n *   // Received data from console\n *   console.log(data);\n * });\n *\n * connection.on(\"statusChange\", (status) => {\n *   console.log(`status changed: ${status}`);\n * });\n * ```\n */\nexport class ConsoleConnection extends EventEmitter implements Connection {\n  private ipAddress: string;\n  private port: number;\n  private isRealtime: boolean;\n  private connectionStatus = ConnectionStatus.DISCONNECTED;\n  private connDetails: ConnectionDetails = { ...defaultConnectionDetails };\n  private client: any | null = null;\n  private connection: inject.Instance<unknown, any> | null = null;\n  private options: ConsoleConnectionOptions;\n  private shouldReconnect = false;\n\n  public constructor(options?: Partial<ConsoleConnectionOptions>) {\n    super();\n    this.ipAddress = \"0.0.0.0\";\n    this.port = Ports.DEFAULT;\n    this.isRealtime = false;\n    this.options = Object.assign({}, consoleConnectionOptions, options);\n  }\n\n  /**\n   * @returns The current connection status.\n   */\n  public getStatus(): ConnectionStatus {\n    return this.connectionStatus;\n  }\n\n  /**\n   * @returns The IP address and port of the current connection.\n   */\n  public getSettings(): ConnectionSettings {\n    return {\n      ipAddress: this.ipAddress,\n      port: this.port,\n    };\n  }\n\n  /**\n   * @returns The specific details about the connected console.\n   */\n  public getDetails(): ConnectionDetails {\n    return { ...this.connDetails };\n  }\n\n  /**\n   * Initiate a connection to the Wii or Slippi relay.\n   * @param ip   The IP address of the Wii or Slippi relay.\n   * @param port The port to connect to.\n   * @param isRealtime Optional. A flag to tell the Wii to send data as quickly as possible\n   * @param timeout Optional. The timeout in milliseconds when attempting to connect\n   *                to the Wii or relay.\n   */\n  public connect(ip: string, port: number, isRealtime = false, timeout = DEFAULT_CONNECTION_TIMEOUT_MS): void {\n    this.ipAddress = ip;\n    this.port = port;\n    this.isRealtime = isRealtime;\n    this._connectOnPort(ip, port, timeout);\n  }\n\n  private _connectOnPort(ip: string, port: number, timeout: number): void {\n    // set up reconnect\n    const reconnect = inject(\n      () => {},\n      // net.connect({\n      //   host: ip,\n      //   port: port,\n      //   timeout: timeout,\n      // }),\n    );\n\n    // Indicate we are connecting\n    this._setStatus(ConnectionStatus.CONNECTING);\n\n    // Prepare console communication obj for talking UBJSON\n    const consoleComms = new ConsoleCommunication();\n\n    // TODO: reconnect on failed reconnect, not sure how\n    // TODO: to do this\n    const connection = reconnect(\n      {\n        initialDelay: 2000,\n        maxDelay: 10000,\n        strategy: \"fibonacci\",\n        failAfter: Infinity,\n      },\n      (client) => {\n        this.emit(ConnectionEvent.CONNECT);\n        // We successfully connected so turn on auto-reconnect\n        this.shouldReconnect = this.options.autoReconnect;\n        this.client = client;\n\n        let commState: CommunicationState = CommunicationState.INITIAL;\n        // client.on(\"data\", (data) => {\n        //   if (commState === CommunicationState.INITIAL) {\n        //     commState = this._getInitialCommState(data);\n        //     console.log(`Connected to ${ip}:${port} with type: ${commState}`);\n        //     this._setStatus(ConnectionStatus.CONNECTED);\n        //     console.log(data.toString(\"hex\"));\n        //   }\n\n        //   if (commState === CommunicationState.LEGACY) {\n        //     // If the first message received was not a handshake message, either we\n        //     // connected to an old Nintendont version or a relay instance\n        //     this._handleReplayData(data);\n        //     return;\n        //   }\n\n        //   try {\n        //     consoleComms.receive(data);\n        //   } catch (err) {\n        //     console.error(\"Failed to process new data from server...\", {\n        //       error: err,\n        //       prevDataBuf: consoleComms.getReceiveBuffer(),\n        //       rcvData: data,\n        //     });\n        //     client.destroy();\n        //     this.emit(ConnectionEvent.ERROR, err);\n        //     return;\n        //   }\n        //   const messages = consoleComms.getMessages();\n\n        //   // Process all of the received messages\n        //   try {\n        //     messages.forEach((message) => this._processMessage(message));\n        //   } catch (err) {\n        //     // Disconnect client to send another handshake message\n        //     console.error(err);\n        //     client.destroy();\n        //     this.emit(ConnectionEvent.ERROR, err);\n        //   }\n        // });\n\n        // client.on(\"timeout\", () => {\n        //   // const previouslyConnected = this.connectionStatus === ConnectionStatus.CONNECTED;\n        //   console.warn(`Attempted connection to ${ip}:${port} timed out after ${timeout}ms`);\n        //   client.destroy();\n        // });\n\n        // client.on(\"end\", () => {\n        //   console.log(\"disconnect\");\n        //   if (!this.shouldReconnect) {\n        //     client.destroy();\n        //   }\n        // });\n\n        // client.on(\"close\", () => {\n        //   console.log(\"connection was closed\");\n        // });\n\n        const handshakeMsgOut = consoleComms.genHandshakeOut(\n          this.connDetails.gameDataCursor as Uint8Array,\n          this.connDetails.clientToken ?? 0,\n          this.isRealtime,\n        );\n\n        // client.write(handshakeMsgOut);\n      },\n    );\n\n    const setConnectingStatus = (): void => {\n      // Indicate we are connecting\n      this._setStatus(this.shouldReconnect ? ConnectionStatus.RECONNECT_WAIT : ConnectionStatus.CONNECTING);\n    };\n\n    connection.on(\"connect\", setConnectingStatus);\n    connection.on(\"reconnect\", setConnectingStatus);\n\n    connection.on(\"disconnect\", () => {\n      if (!this.shouldReconnect) {\n        connection.reconnect = false;\n        connection.disconnect();\n        this._setStatus(ConnectionStatus.DISCONNECTED);\n      }\n      // TODO: Figure out how to set RECONNECT_WAIT state here. Currently it will stay on\n      // TODO: Connecting... forever\n    });\n\n    connection.on(\"error\", (err) => {\n      console.warn(`Connection on port ${port} encountered an error.`, err);\n\n      this._setStatus(ConnectionStatus.DISCONNECTED);\n      this.emit(ConnectionEvent.ERROR, `Connection on port ${port} encountered an error.\\n${err}`);\n    });\n\n    this.connection = connection;\n    connection.connect(port);\n  }\n\n  /**\n   * Terminate the current connection.\n   */\n  public disconnect(): void {\n    // Prevent reconnections and disconnect\n    if (this.connection) {\n      this.connection.reconnect = false;\n      this.connection.disconnect();\n      this.connection = null;\n    }\n\n    if (this.client) {\n      this.client.destroy();\n    }\n  }\n\n  private _getInitialCommState(data: Buffer): CommunicationState {\n    if (data.length < 13) {\n      return CommunicationState.LEGACY;\n    }\n\n    const openingBytes = Buffer.from([0x7b, 0x69, 0x04, 0x74, 0x79, 0x70, 0x65, 0x55, 0x01]);\n\n    const dataStart = data.slice(4, 13);\n\n    return dataStart.equals(openingBytes) ? CommunicationState.NORMAL : CommunicationState.LEGACY;\n  }\n\n  private _processMessage(message: CommunicationMessage): void {\n    this.emit(ConnectionEvent.MESSAGE, message);\n    switch (message.type) {\n      case CommunicationType.KEEP_ALIVE:\n        // console.log(\"Keep alive message received\");\n\n        // TODO: This is the jankiest shit ever but it will allow for relay connections not\n        // TODO: to time out as long as the main connection is still receving keep alive messages\n        // TODO: Need to figure out a better solution for this. There should be no need to have an\n        // TODO: active Wii connection for the relay connection to keep itself alive\n        const fakeKeepAlive = Buffer.from(NETWORK_MESSAGE);\n        this._handleReplayData(fakeKeepAlive);\n\n        break;\n      case CommunicationType.REPLAY:\n        const readPos = Uint8Array.from(message.payload.pos);\n        const cmp = Buffer.compare(this.connDetails.gameDataCursor as Uint8Array, readPos);\n        if (!message.payload.forcePos && cmp !== 0) {\n          // The readPos is not the one we are waiting on, throw error\n          throw new Error(\n            `Position of received data is incorrect. Expected: ${this.connDetails.gameDataCursor.toString()}, Received: ${readPos.toString()}`,\n          );\n        }\n\n        if (message.payload.forcePos) {\n          console.warn(\n            \"Overflow occured in Nintendont, data has likely been skipped and replay corrupted. \" +\n              \"Expected, Received:\",\n            this.connDetails.gameDataCursor,\n            readPos,\n          );\n        }\n\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.nextPos);\n\n        const data = Uint8Array.from(message.payload.data);\n        this._handleReplayData(data);\n        break;\n      case CommunicationType.HANDSHAKE:\n        const { nick, nintendontVersion } = message.payload;\n        if (nick) {\n          this.connDetails.consoleNick = nick;\n        }\n        const tokenBuf = Buffer.from(message.payload.clientToken);\n        this.connDetails.clientToken = tokenBuf.readUInt32BE(0);\n        if (nintendontVersion) {\n          this.connDetails.version = nintendontVersion;\n        }\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.pos);\n        this.emit(ConnectionEvent.HANDSHAKE, this.connDetails);\n        break;\n      default:\n        // Should this be an error?\n        break;\n    }\n  }\n\n  private _handleReplayData(data: Uint8Array): void {\n    this.emit(ConnectionEvent.DATA, data);\n  }\n\n  private _setStatus(status: ConnectionStatus): void {\n    // Don't fire the event if the status hasn't actually changed\n    if (this.connectionStatus !== status) {\n      this.connectionStatus = status;\n      this.emit(ConnectionEvent.STATUS_CHANGE, this.connectionStatus);\n    }\n  }\n}\n","import { EventEmitter } from \"events\";\n\nimport type { Connection, ConnectionDetails, ConnectionSettings } from \"./types\";\nimport { ConnectionEvent, ConnectionStatus, Ports } from \"./types\";\n\nconst MAX_PEERS = 32;\n\nexport enum DolphinMessageType {\n  CONNECT_REPLY = \"connect_reply\",\n  GAME_EVENT = \"game_event\",\n  START_GAME = \"start_game\",\n  END_GAME = \"end_game\",\n}\n\nexport class DolphinConnection extends EventEmitter implements Connection {\n  private ipAddress: string;\n  private port: number;\n  private connectionStatus = ConnectionStatus.DISCONNECTED;\n  private gameCursor = 0;\n  private nickname = \"unknown\";\n  private version = \"\";\n  private peer: any | null = null;\n\n  public constructor() {\n    super();\n    this.ipAddress = \"0.0.0.0\";\n    this.port = Ports.DEFAULT;\n  }\n\n  /**\n   * @returns The current connection status.\n   */\n  public getStatus(): ConnectionStatus {\n    return this.connectionStatus;\n  }\n\n  /**\n   * @returns The IP address and port of the current connection.\n   */\n  public getSettings(): ConnectionSettings {\n    return {\n      ipAddress: this.ipAddress,\n      port: this.port,\n    };\n  }\n\n  public getDetails(): ConnectionDetails {\n    return {\n      consoleNick: this.nickname,\n      gameDataCursor: this.gameCursor,\n      version: this.version,\n    };\n  }\n\n  public async connect(ip: string, port: number): Promise<void> {\n    console.log(`Connecting to: ${ip}:${port}`);\n    this.ipAddress = ip;\n    this.port = port;\n\n    const enet = await import(\"enet\");\n    // Create the enet client\n    const client = enet.createClient({ peers: MAX_PEERS, channels: 3, down: 0, up: 0 }, (err) => {\n      if (err) {\n        console.error(err);\n        return;\n      }\n    });\n\n    this.peer = client.connect(\n      {\n        address: this.ipAddress,\n        port: this.port,\n      },\n      3,\n      1337, // Data to send, not sure what this is or what this represents\n      (err: any, newPeer: any) => {\n        if (err) {\n          console.error(err);\n          return;\n        }\n\n        newPeer.ping();\n        this.emit(ConnectionEvent.CONNECT);\n        this._setStatus(ConnectionStatus.CONNECTED);\n      },\n    );\n\n    this.peer.on(\"connect\", () => {\n      // Reset the game cursor to the beginning of the game. Do we need to do this or\n      // should it just continue from where it left off?\n      this.gameCursor = 0;\n\n      const request = {\n        type: \"connect_request\",\n        cursor: this.gameCursor,\n      };\n      const packet = new enet.Packet(JSON.stringify(request), enet.PACKET_FLAG.RELIABLE);\n      this.peer.send(0, packet);\n    });\n\n    this.peer.on(\"message\", (packet: any) => {\n      const data = packet.data();\n      if (data.length === 0) {\n        return;\n      }\n\n      const dataString = data.toString(\"ascii\");\n      const message = JSON.parse(dataString);\n      const { dolphin_closed } = message;\n      if (dolphin_closed) {\n        // We got a disconnection request\n        this.disconnect();\n        return;\n      }\n      this.emit(ConnectionEvent.MESSAGE, message);\n      switch (message.type) {\n        case DolphinMessageType.CONNECT_REPLY:\n          this.connectionStatus = ConnectionStatus.CONNECTED;\n          this.gameCursor = message.cursor;\n          this.nickname = message.nick;\n          this.version = message.version;\n          this.emit(ConnectionEvent.HANDSHAKE, this.getDetails());\n          break;\n        case DolphinMessageType.GAME_EVENT: {\n          const { payload } = message;\n          //TODO: remove after game start and end messages have been in stable Ishii for a bit\n          if (!payload) {\n            // We got a disconnection request\n            this.disconnect();\n            return;\n          }\n\n          this._updateCursor(message, dataString);\n\n          const gameData = Buffer.from(payload, \"base64\");\n          this._handleReplayData(gameData);\n          break;\n        }\n        case DolphinMessageType.START_GAME: {\n          this._updateCursor(message, dataString);\n          break;\n        }\n        case DolphinMessageType.END_GAME: {\n          this._updateCursor(message, dataString);\n          break;\n        }\n      }\n    });\n\n    this.peer.on(\"disconnect\", () => {\n      this.disconnect();\n    });\n\n    this._setStatus(ConnectionStatus.CONNECTING);\n  }\n\n  public disconnect(): void {\n    if (this.peer) {\n      this.peer.disconnect();\n      this.peer = null;\n    }\n    this._setStatus(ConnectionStatus.DISCONNECTED);\n  }\n\n  private _handleReplayData(data: Uint8Array): void {\n    this.emit(ConnectionEvent.DATA, data);\n  }\n\n  private _setStatus(status: ConnectionStatus): void {\n    // Don't fire the event if the status hasn't actually changed\n    if (this.connectionStatus !== status) {\n      this.connectionStatus = status;\n      this.emit(ConnectionEvent.STATUS_CHANGE, this.connectionStatus);\n    }\n  }\n\n  private _updateCursor(message: { cursor: number; next_cursor: number }, dataString: string): void {\n    const { cursor, next_cursor } = message;\n\n    if (this.gameCursor !== cursor) {\n      const err = new Error(\n        `Unexpected game data cursor. Expected: ${this.gameCursor} but got: ${cursor}. Payload: ${dataString}`,\n      );\n      console.warn(err);\n      this.emit(ConnectionEvent.ERROR, err);\n    }\n\n    this.gameCursor = next_cursor;\n  }\n}\n","import { decode } from \"@shelacek/ubjson\";\nimport iconv from \"iconv-lite\";\nimport mapValues from \"lodash/mapValues\";\n\nimport type {\n  EventCallbackFunc,\n  EventPayloadTypes,\n  GameEndType,\n  GameInfoType,\n  GameStartType,\n  GeckoCodeType,\n  MetadataType,\n  PlacementType,\n  PlayerType,\n  PostFrameUpdateType,\n  SelfInducedSpeedsType,\n} from \"../types\";\nimport { Command } from \"../types\";\nimport { exists } from \"./exists\";\nimport { toHalfwidth } from \"./fullwidth\";\n\nexport enum SlpInputSource {\n  BUFFER = \"buffer\",\n  FILE = \"file\",\n}\n\ntype SlpFileReadInput = {\n  source: SlpInputSource.FILE;\n  filePath: string;\n};\n\ntype SlpBufferReadInput = {\n  source: SlpInputSource.BUFFER;\n  buffer: Buffer;\n};\n\nexport type SlpReadInput = SlpFileReadInput | SlpBufferReadInput;\n\nexport type SlpRefType = SlpFileSourceRef | SlpBufferSourceRef;\n\nexport type SlpFileType = {\n  ref: SlpRefType;\n  rawDataPosition: number;\n  rawDataLength: number;\n  metadataPosition: number;\n  metadataLength: number;\n  messageSizes: {\n    [command: number]: number;\n  };\n};\n\nexport type SlpFileSourceRef = {\n  source: SlpInputSource.FILE;\n  fileDescriptor: number;\n};\n\nexport type SlpBufferSourceRef = {\n  source: SlpInputSource.BUFFER;\n  buffer: Buffer;\n};\n\nfunction getRef(input: SlpReadInput): SlpRefType {\n  switch (input.source) {\n    case SlpInputSource.BUFFER:\n      return {\n        source: input.source,\n        buffer: input.buffer,\n      };\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\nfunction readRef(ref: SlpRefType, buffer: Uint8Array, offset: number, length: number, position: number): number {\n  switch (ref.source) {\n    case SlpInputSource.FILE:\n      console.error(\"deleted this for cloudflare worker support :)\");\n\n      throw new Error(\"cfw support\");\n    case SlpInputSource.BUFFER:\n      if (position >= ref.buffer.length) {\n        return 0;\n      }\n      return ref.buffer.copy(buffer, offset, position, position + length);\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\nfunction getLenRef(ref: SlpRefType): number {\n  switch (ref.source) {\n    case SlpInputSource.FILE:\n      console.error(\"deleted this for cloudflare worker support :)\");\n\n      throw new Error(\"cfw support\");\n    case SlpInputSource.BUFFER:\n      return ref.buffer.length;\n    default:\n      throw new Error(\"Source type not supported\");\n  }\n}\n\n/**\n * Opens a file at path\n */\nexport function openSlpFile(input: SlpReadInput): SlpFileType {\n  const ref = getRef(input);\n\n  const rawDataPosition = getRawDataPosition(ref);\n  const rawDataLength = getRawDataLength(ref, rawDataPosition);\n  const metadataPosition = rawDataPosition + rawDataLength + 10; // remove metadata string\n  const metadataLength = getMetadataLength(ref, metadataPosition);\n  const messageSizes = getMessageSizes(ref, rawDataPosition);\n\n  return {\n    ref,\n    rawDataPosition,\n    rawDataLength,\n    metadataPosition,\n    metadataLength,\n    messageSizes,\n  };\n}\n\nexport function closeSlpFile(file: SlpFileType): void {\n  switch (file.ref.source) {\n  }\n}\n\n// This function gets the position where the raw data starts\nfunction getRawDataPosition(ref: SlpRefType): number {\n  const buffer = new Uint8Array(1);\n  readRef(ref, buffer, 0, buffer.length, 0);\n\n  if (buffer[0] === 0x36) {\n    return 0;\n  }\n\n  if (buffer[0] !== \"{\".charCodeAt(0)) {\n    return 0; // return error?\n  }\n\n  return 15;\n}\n\nfunction getRawDataLength(ref: SlpRefType, position: number): number {\n  const fileSize = getLenRef(ref);\n  if (position === 0) {\n    return fileSize;\n  }\n\n  const buffer = new Uint8Array(4);\n  readRef(ref, buffer, 0, buffer.length, position - 4);\n\n  const rawDataLen = (buffer[0]! << 24) | (buffer[1]! << 16) | (buffer[2]! << 8) | buffer[3]!;\n  if (rawDataLen > 0) {\n    // If this method manages to read a number, it's probably trustworthy\n    return rawDataLen;\n  }\n\n  // If the above does not return a valid data length,\n  // return a file size based on file length. This enables\n  // some support for severed files\n  return fileSize - position;\n}\n\nfunction getMetadataLength(ref: SlpRefType, position: number): number {\n  const len = getLenRef(ref);\n  return len - position - 1;\n}\n\nfunction getMessageSizes(\n  ref: SlpRefType,\n  position: number,\n): {\n  [command: number]: number;\n} {\n  const messageSizes: {\n    [command: number]: number;\n  } = {};\n  // Support old file format\n  if (position === 0) {\n    messageSizes[0x36] = 0x140;\n    messageSizes[0x37] = 0x6;\n    messageSizes[0x38] = 0x46;\n    messageSizes[0x39] = 0x1;\n    return messageSizes;\n  }\n\n  const buffer = new Uint8Array(2);\n  readRef(ref, buffer, 0, buffer.length, position);\n  if (buffer[0] !== Command.MESSAGE_SIZES) {\n    return {};\n  }\n\n  const payloadLength = buffer[1] as number;\n  (messageSizes[0x35] as any) = payloadLength;\n\n  const messageSizesBuffer = new Uint8Array(payloadLength - 1);\n  readRef(ref, messageSizesBuffer, 0, messageSizesBuffer.length, position + 2);\n  for (let i = 0; i < payloadLength - 1; i += 3) {\n    const command = messageSizesBuffer[i] as number;\n\n    // Get size of command\n    (messageSizes[command] as any) = (messageSizesBuffer[i + 1]! << 8) | messageSizesBuffer[i + 2]!;\n  }\n\n  return messageSizes;\n}\n\nfunction getEnabledItems(view: DataView): number {\n  const offsets = [0x1, 0x100, 0x10000, 0x1000000, 0x100000000];\n  const enabledItems = offsets.reduce((acc, byteOffset, index) => {\n    const byte = readUint8(view, 0x28 + index) as number;\n    return acc + byte * byteOffset;\n  }, 0);\n\n  return enabledItems;\n}\n\nfunction getGameInfoBlock(view: DataView): GameInfoType {\n  const offset = 0x5;\n\n  return {\n    gameBitfield1: readUint8(view, 0x0 + offset),\n    gameBitfield2: readUint8(view, 0x1 + offset),\n    gameBitfield3: readUint8(view, 0x2 + offset),\n    gameBitfield4: readUint8(view, 0x3 + offset),\n    bombRainEnabled: (readUint8(view, 0x6 + offset)! & 0xff) > 0 ? true : false,\n    selfDestructScoreValue: readInt8(view, 0xc + offset),\n    itemSpawnBitfield1: readUint8(view, 0x23 + offset),\n    itemSpawnBitfield2: readUint8(view, 0x24 + offset),\n    itemSpawnBitfield3: readUint8(view, 0x25 + offset),\n    itemSpawnBitfield4: readUint8(view, 0x26 + offset),\n    itemSpawnBitfield5: readUint8(view, 0x27 + offset),\n    damageRatio: readFloat(view, 0x30 + offset),\n  };\n}\n\n/**\n * Iterates through slp events and parses payloads\n */\nexport function iterateEvents(\n  slpFile: SlpFileType,\n  callback: EventCallbackFunc,\n  startPos: number | null = null,\n): number {\n  const ref = slpFile.ref;\n\n  let readPosition = startPos !== null && startPos > 0 ? startPos : slpFile.rawDataPosition;\n  const stopReadingAt = slpFile.rawDataPosition + slpFile.rawDataLength;\n\n  // Generate read buffers for each\n  const commandPayloadBuffers = mapValues(slpFile.messageSizes, (size) => new Uint8Array(size + 1));\n  let splitMessageBuffer = new Uint8Array(0);\n\n  const commandByteBuffer = new Uint8Array(1);\n  while (readPosition < stopReadingAt) {\n    readRef(ref, commandByteBuffer, 0, 1, readPosition);\n    let commandByte = (commandByteBuffer[0] as number) ?? 0;\n    let buffer = commandPayloadBuffers[commandByte];\n    if (buffer === undefined) {\n      // If we don't have an entry for this command, return false to indicate failed read\n      return readPosition;\n    }\n\n    if (buffer.length > stopReadingAt - readPosition) {\n      return readPosition;\n    }\n\n    const advanceAmount = buffer.length;\n\n    readRef(ref, buffer, 0, buffer.length, readPosition);\n    if (commandByte === Command.SPLIT_MESSAGE) {\n      // Here we have a split message, we will collect data from them until the last\n      // message of the list is received\n      const view = new DataView(buffer.buffer);\n      const size = readUint16(view, 0x201) ?? 512;\n      const isLastMessage = readBool(view, 0x204);\n      const internalCommand = readUint8(view, 0x203) ?? 0;\n\n      // If this is the first message, initialize the splitMessageBuffer\n      // with the internal command byte because our parseMessage function\n      // seems to expect a command byte at the start\n      if (splitMessageBuffer.length === 0) {\n        splitMessageBuffer = new Uint8Array(1);\n        splitMessageBuffer[0] = internalCommand;\n      }\n\n      // Collect new data into splitMessageBuffer\n      const appendBuf = buffer.slice(0x1, 0x1 + size);\n      const mergedBuf = new Uint8Array(splitMessageBuffer.length + appendBuf.length);\n      mergedBuf.set(splitMessageBuffer);\n      mergedBuf.set(appendBuf, splitMessageBuffer.length);\n      splitMessageBuffer = mergedBuf;\n\n      if (isLastMessage) {\n        commandByte = splitMessageBuffer[0] ?? 0;\n        buffer = splitMessageBuffer;\n        splitMessageBuffer = new Uint8Array(0);\n      }\n    }\n\n    const parsedPayload = parseMessage(commandByte, buffer);\n    const shouldStop = callback(commandByte, parsedPayload, buffer);\n    if (shouldStop) {\n      break;\n    }\n\n    readPosition += advanceAmount;\n  }\n\n  return readPosition;\n}\n\nexport function parseMessage(command: Command, payload: Uint8Array): EventPayloadTypes | null {\n  const view = new DataView(payload.buffer);\n  switch (command) {\n    case Command.GAME_START:\n      const getPlayerObject = (playerIndex: number): PlayerType => {\n        // Controller Fix stuff\n        const cfOffset = playerIndex * 0x8;\n        const dashback = readUint32(view, 0x141 + cfOffset);\n        const shieldDrop = readUint32(view, 0x145 + cfOffset);\n        let controllerFix = \"None\";\n        if (dashback !== shieldDrop) {\n          controllerFix = \"Mixed\";\n        } else if (dashback === 1) {\n          controllerFix = \"UCF\";\n        } else if (dashback === 2) {\n          controllerFix = \"Dween\";\n        }\n\n        // Nametag stuff\n        const nametagLength = 0x10;\n        const nametagOffset = playerIndex * nametagLength;\n        const nametagStart = 0x161 + nametagOffset;\n        const nametagBuf = payload.slice(nametagStart, nametagStart + nametagLength);\n        const nameTagString = iconv\n          .decode(nametagBuf as Buffer, \"Shift_JIS\")\n          .split(\"\\0\")\n          .shift();\n        const nametag = nameTagString ? toHalfwidth(nameTagString) : \"\";\n\n        // Display name\n        const displayNameLength = 0x1f;\n        const displayNameOffset = playerIndex * displayNameLength;\n        const displayNameStart = 0x1a5 + displayNameOffset;\n        const displayNameBuf = payload.slice(displayNameStart, displayNameStart + displayNameLength);\n        const displayNameString = iconv\n          .decode(displayNameBuf as Buffer, \"Shift_JIS\")\n          .split(\"\\0\")\n          .shift();\n        const displayName = displayNameString ? toHalfwidth(displayNameString) : \"\";\n\n        // Connect code\n        const connectCodeLength = 0xa;\n        const connectCodeOffset = playerIndex * connectCodeLength;\n        const connectCodeStart = 0x221 + connectCodeOffset;\n        const connectCodeBuf = payload.slice(connectCodeStart, connectCodeStart + connectCodeLength);\n        const connectCodeString = iconv\n          .decode(connectCodeBuf as Buffer, \"Shift_JIS\")\n          .split(\"\\0\")\n          .shift();\n        const connectCode = connectCodeString ? toHalfwidth(connectCodeString) : \"\";\n\n        const userIdLength = 0x1d;\n        const userIdOffset = playerIndex * userIdLength;\n        const userIdStart = 0x249 + userIdOffset;\n        const userIdBuf = payload.slice(userIdStart, userIdStart + userIdLength);\n        const userIdString = iconv\n          .decode(userIdBuf as Buffer, \"utf8\")\n          .split(\"\\0\")\n          .shift();\n        const userId = userIdString ?? \"\";\n\n        const offset = playerIndex * 0x24;\n        const playerInfo: PlayerType = {\n          playerIndex,\n          port: playerIndex + 1,\n          characterId: readUint8(view, 0x65 + offset),\n          type: readUint8(view, 0x66 + offset),\n          startStocks: readUint8(view, 0x67 + offset),\n          characterColor: readUint8(view, 0x68 + offset),\n          teamShade: readUint8(view, 0x6c + offset),\n          handicap: readUint8(view, 0x6d + offset),\n          teamId: readUint8(view, 0x6e + offset),\n          staminaMode: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x01)),\n          silentCharacter: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x02)),\n          lowGravity: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x04)),\n          invisible: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x08)),\n          blackStockIcon: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x10)),\n          metal: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x20)),\n          startOnAngelPlatform: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x40)),\n          rumbleEnabled: Boolean(readUint8(view, 0x6c + playerIndex * 0x24, 0x80)),\n          cpuLevel: readUint8(view, 0x74 + offset),\n          offenseRatio: readFloat(view, 0x7d + offset),\n          defenseRatio: readFloat(view, 0x81 + offset),\n          modelScale: readFloat(view, 0x85 + offset),\n          controllerFix,\n          nametag,\n          displayName,\n          connectCode,\n          userId,\n        };\n        return playerInfo;\n      };\n\n      const matchIdLength = 51;\n      const matchIdStart = 0x2be;\n      const matchIdBuf = payload.slice(matchIdStart, matchIdStart + matchIdLength);\n      const matchIdString = iconv\n        .decode(matchIdBuf as Buffer, \"utf8\")\n        .split(\"\\0\")\n        .shift();\n      const matchId = matchIdString ?? \"\";\n\n      const gameSettings: GameStartType = {\n        slpVersion: `${readUint8(view, 0x1)}.${readUint8(view, 0x2)}.${readUint8(view, 0x3)}`,\n        timerType: readUint8(view, 0x5, 0x03),\n        inGameMode: readUint8(view, 0x5, 0xe0),\n        friendlyFireEnabled: !!readUint8(view, 0x6, 0x01),\n        isTeams: readBool(view, 0xd),\n        itemSpawnBehavior: readUint8(view, 0x10),\n        stageId: readUint16(view, 0x13),\n        startingTimerSeconds: readUint32(view, 0x15),\n        enabledItems: getEnabledItems(view),\n        players: [0, 1, 2, 3].map(getPlayerObject),\n        scene: readUint8(view, 0x1a3),\n        gameMode: readUint8(view, 0x1a4),\n        language: readUint8(view, 0x2bd),\n        gameInfoBlock: getGameInfoBlock(view),\n        randomSeed: readUint32(view, 0x13d),\n        isPAL: readBool(view, 0x1a1),\n        isFrozenPS: readBool(view, 0x1a2),\n        matchInfo: {\n          matchId,\n          gameNumber: readUint32(view, 0x2f1),\n          tiebreakerNumber: readUint32(view, 0x2f5),\n        },\n      };\n      return gameSettings;\n    case Command.FRAME_START:\n      return {\n        frame: readInt32(view, 0x1),\n        seed: readUint32(view, 0x5),\n        sceneFrameCounter: readUint32(view, 0x9),\n      };\n\n    case Command.PRE_FRAME_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        seed: readUint32(view, 0x7),\n        actionStateId: readUint16(view, 0xb),\n        positionX: readFloat(view, 0xd),\n        positionY: readFloat(view, 0x11),\n        facingDirection: readFloat(view, 0x15),\n        joystickX: readFloat(view, 0x19),\n        joystickY: readFloat(view, 0x1d),\n        cStickX: readFloat(view, 0x21),\n        cStickY: readFloat(view, 0x25),\n        trigger: readFloat(view, 0x29),\n        buttons: readUint32(view, 0x2d),\n        physicalButtons: readUint16(view, 0x31),\n        physicalLTrigger: readFloat(view, 0x33),\n        physicalRTrigger: readFloat(view, 0x37),\n        rawJoystickX: readInt8(view, 0x3b),\n        percent: readFloat(view, 0x3c),\n      };\n    case Command.POST_FRAME_UPDATE:\n      const selfInducedSpeeds: SelfInducedSpeedsType = {\n        airX: readFloat(view, 0x35),\n        y: readFloat(view, 0x39),\n        attackX: readFloat(view, 0x3d),\n        attackY: readFloat(view, 0x41),\n        groundX: readFloat(view, 0x45),\n      };\n      return {\n        frame: readInt32(view, 0x1),\n        playerIndex: readUint8(view, 0x5),\n        isFollower: readBool(view, 0x6),\n        internalCharacterId: readUint8(view, 0x7),\n        actionStateId: readUint16(view, 0x8),\n        positionX: readFloat(view, 0xa),\n        positionY: readFloat(view, 0xe),\n        facingDirection: readFloat(view, 0x12),\n        percent: readFloat(view, 0x16),\n        shieldSize: readFloat(view, 0x1a),\n        lastAttackLanded: readUint8(view, 0x1e),\n        currentComboCount: readUint8(view, 0x1f),\n        lastHitBy: readUint8(view, 0x20),\n        stocksRemaining: readUint8(view, 0x21),\n        actionStateCounter: readFloat(view, 0x22),\n        miscActionState: readFloat(view, 0x2b),\n        isAirborne: readBool(view, 0x2f),\n        lastGroundId: readUint16(view, 0x30),\n        jumpsRemaining: readUint8(view, 0x32),\n        lCancelStatus: readUint8(view, 0x33),\n        hurtboxCollisionState: readUint8(view, 0x34),\n        selfInducedSpeeds: selfInducedSpeeds,\n        hitlagRemaining: readFloat(view, 0x49),\n        animationIndex: readUint32(view, 0x4d),\n        instanceHitBy: readUint16(view, 0x51),\n        instanceId: readUint16(view, 0x53),\n      };\n    case Command.ITEM_UPDATE:\n      return {\n        frame: readInt32(view, 0x1),\n        typeId: readUint16(view, 0x5),\n        state: readUint8(view, 0x7),\n        facingDirection: readFloat(view, 0x8),\n        velocityX: readFloat(view, 0xc),\n        velocityY: readFloat(view, 0x10),\n        positionX: readFloat(view, 0x14),\n        positionY: readFloat(view, 0x18),\n        damageTaken: readUint16(view, 0x1c),\n        expirationTimer: readFloat(view, 0x1e),\n        spawnId: readUint32(view, 0x22),\n        missileType: readUint8(view, 0x26),\n        turnipFace: readUint8(view, 0x27),\n        chargeShotLaunched: readUint8(view, 0x28),\n        chargePower: readUint8(view, 0x29),\n        owner: readInt8(view, 0x2a),\n        instanceId: readUint16(view, 0x2b),\n      };\n    case Command.FRAME_BOOKEND:\n      return {\n        frame: readInt32(view, 0x1),\n        latestFinalizedFrame: readInt32(view, 0x5),\n      };\n    case Command.GAME_END:\n      const placements = [0, 1, 2, 3].map((playerIndex): PlacementType => {\n        const position = readInt8(view, 0x3 + playerIndex);\n        return { playerIndex, position };\n      });\n\n      return {\n        gameEndMethod: readUint8(view, 0x1),\n        lrasInitiatorIndex: readInt8(view, 0x2),\n        placements,\n      };\n    case Command.GECKO_LIST:\n      const codes: GeckoCodeType[] = [];\n      let pos = 1;\n      while (pos < payload.length) {\n        const word1 = readUint32(view, pos) ?? 0;\n        const codetype = (word1 >> 24) & 0xfe;\n        const address = (word1 & 0x01ffffff) + 0x80000000;\n\n        let offset = 8; // Default code length, most codes are this length\n        if (codetype === 0xc0 || codetype === 0xc2) {\n          const lineCount = readUint32(view, pos + 4) ?? 0;\n          offset = 8 + lineCount * 8;\n        } else if (codetype === 0x06) {\n          const byteLen = readUint32(view, pos + 4) ?? 0;\n          offset = 8 + ((byteLen + 7) & 0xfffffff8);\n        } else if (codetype === 0x08) {\n          offset = 16;\n        }\n\n        codes.push({\n          type: codetype,\n          address: address,\n          contents: payload.slice(pos, pos + offset),\n        });\n\n        pos += offset;\n      }\n\n      return {\n        contents: payload.slice(1),\n        codes: codes,\n      };\n    default:\n      return null;\n  }\n}\n\nfunction canReadFromView(view: DataView, offset: number, length: number): boolean {\n  const viewLength = view.byteLength;\n  return offset + length <= viewLength;\n}\n\nfunction readFloat(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getFloat32(offset);\n}\n\nfunction readInt32(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getInt32(offset);\n}\n\nfunction readInt8(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getInt8(offset);\n}\n\nfunction readUint32(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 4)) {\n    return null;\n  }\n\n  return view.getUint32(offset);\n}\n\nfunction readUint16(view: DataView, offset: number): number | null {\n  if (!canReadFromView(view, offset, 2)) {\n    return null;\n  }\n\n  return view.getUint16(offset);\n}\n\nfunction readUint8(view: DataView, offset: number, bitmask = 0xff): number | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return view.getUint8(offset) & bitmask;\n}\n\nfunction readBool(view: DataView, offset: number): boolean | null {\n  if (!canReadFromView(view, offset, 1)) {\n    return null;\n  }\n\n  return !!view.getUint8(offset);\n}\n\nexport function getMetadata(slpFile: SlpFileType): MetadataType | null {\n  if (slpFile.metadataLength <= 0) {\n    // This will happen on a severed incomplete file\n    // $FlowFixMe\n    return null;\n  }\n\n  const buffer = new Uint8Array(slpFile.metadataLength);\n\n  readRef(slpFile.ref, buffer, 0, buffer.length, slpFile.metadataPosition);\n\n  let metadata = null;\n  try {\n    metadata = decode(buffer);\n  } catch (ex) {\n    // Do nothing\n    // console.log(ex);\n  }\n\n  // $FlowFixMe\n  return metadata;\n}\n\nexport function getGameEnd(slpFile: SlpFileType): GameEndType | null {\n  const { ref, rawDataPosition, rawDataLength, messageSizes } = slpFile;\n  const gameEndPayloadSize = messageSizes[Command.GAME_END];\n  if (!exists(gameEndPayloadSize) || gameEndPayloadSize <= 0) {\n    return null;\n  }\n\n  // Add one to account for command byte\n  const gameEndSize = gameEndPayloadSize + 1;\n  const gameEndPosition = rawDataPosition + rawDataLength - gameEndSize;\n\n  const buffer = new Uint8Array(gameEndSize);\n  readRef(ref, buffer, 0, buffer.length, gameEndPosition);\n  if (buffer[0] !== Command.GAME_END) {\n    // This isn't even a game end payload\n    return null;\n  }\n\n  const gameEndMessage = parseMessage(Command.GAME_END, buffer);\n  if (!gameEndMessage) {\n    return null;\n  }\n\n  return gameEndMessage as GameEndType;\n}\n\nexport function extractFinalPostFrameUpdates(slpFile: SlpFileType): PostFrameUpdateType[] {\n  const { ref, rawDataPosition, rawDataLength, messageSizes } = slpFile;\n\n  // The following should exist on all replay versions\n  const postFramePayloadSize = messageSizes[Command.POST_FRAME_UPDATE];\n  const gameEndPayloadSize = messageSizes[Command.GAME_END];\n  const frameBookendPayloadSize = messageSizes[Command.FRAME_BOOKEND];\n\n  // Technically this should not be possible\n  if (!exists(postFramePayloadSize)) {\n    return [];\n  }\n\n  const gameEndSize = gameEndPayloadSize ? gameEndPayloadSize + 1 : 0;\n  const postFrameSize = postFramePayloadSize + 1;\n  const frameBookendSize = frameBookendPayloadSize ? frameBookendPayloadSize + 1 : 0;\n\n  let frameNum: number | null = null;\n  let postFramePosition = rawDataPosition + rawDataLength - gameEndSize - frameBookendSize - postFrameSize;\n  const postFrameUpdates: PostFrameUpdateType[] = [];\n  do {\n    const buffer = new Uint8Array(postFrameSize);\n    readRef(ref, buffer, 0, buffer.length, postFramePosition);\n    if (buffer[0] !== Command.POST_FRAME_UPDATE) {\n      break;\n    }\n\n    const postFrameMessage = parseMessage(Command.POST_FRAME_UPDATE, buffer) as PostFrameUpdateType | null;\n    if (!postFrameMessage) {\n      break;\n    }\n\n    if (frameNum === null) {\n      frameNum = postFrameMessage.frame;\n    } else if (frameNum !== postFrameMessage.frame) {\n      // If post frame message is found but the frame doesn't match, it's not part of the final frame\n      break;\n    }\n\n    postFrameUpdates.unshift(postFrameMessage);\n    postFramePosition -= postFrameSize;\n  } while (postFramePosition >= rawDataPosition);\n\n  return postFrameUpdates;\n}\n","import type { WritableOptions } from \"stream\";\nimport { Writable } from \"stream\";\n\nimport { NETWORK_MESSAGE } from \"../console\";\nimport type { EventPayloadTypes } from \"../types\";\nimport { Command } from \"../types\";\nimport { parseMessage } from \"./slpReader\";\n\nexport enum SlpStreamMode {\n  AUTO = \"AUTO\", // Always reading data, but errors on invalid command\n  MANUAL = \"MANUAL\", // Stops parsing inputs after a valid game end command, requires manual restarting\n}\n\nconst defaultSettings = {\n  suppressErrors: false,\n  mode: SlpStreamMode.AUTO,\n};\n\nexport type SlpStreamSettings = typeof defaultSettings;\n\nexport type MessageSizes = Map<Command, number>;\n\nexport type SlpCommandEventPayload = {\n  command: Command;\n  payload: EventPayloadTypes | MessageSizes;\n};\n\nexport type SlpRawEventPayload = {\n  command: Command;\n  payload: Buffer;\n};\n\nexport enum SlpStreamEvent {\n  RAW = \"slp-raw\",\n  COMMAND = \"slp-command\",\n}\n\n/**\n * SlpStream is a writable stream of Slippi data. It passes the data being written in\n * and emits an event based on what kind of Slippi messages were processed.\n *\n * SlpStream emits two events: \"slp-raw\" and \"slp-command\". The \"slp-raw\" event emits the raw buffer\n * bytes whenever it processes each command. You can manually parse this or write it to a\n * file. The \"slp-command\" event returns the parsed payload which you can access the attributes.\n *\n * @class SlpStream\n * @extends {Writable}\n */\nexport class SlpStream extends Writable {\n  private gameEnded = false; // True only if in manual mode and the game has completed\n  private settings: SlpStreamSettings;\n  private payloadSizes: MessageSizes | null = null;\n  private previousBuffer: Uint8Array = Buffer.from([]);\n\n  /**\n   *Creates an instance of SlpStream.\n   * @param {Partial<SlpStreamSettings>} [slpOptions]\n   * @param {WritableOptions} [opts]\n   * @memberof SlpStream\n   */\n  public constructor(slpOptions?: Partial<SlpStreamSettings>, opts?: WritableOptions) {\n    super(opts);\n    this.settings = Object.assign({}, defaultSettings, slpOptions);\n  }\n\n  public restart(): void {\n    this.gameEnded = false;\n    this.payloadSizes = null;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public _write(newData: Buffer, encoding: string, callback: (error?: Error | null, data?: any) => void): void {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    }\n\n    // Join the current data with the old data\n    const data = Uint8Array.from(Buffer.concat([this.previousBuffer, newData]));\n\n    // Clear previous data\n    this.previousBuffer = Buffer.from([]);\n\n    const dataView = new DataView(data.buffer);\n\n    // Iterate through the data\n    let index = 0;\n    while (index < data.length) {\n      // We want to filter out the network messages\n      if (Buffer.from(data.slice(index, index + 5)).toString() === NETWORK_MESSAGE) {\n        index += 5;\n        continue;\n      }\n\n      // Make sure we have enough data to read a full payload\n      const command = dataView.getUint8(index);\n      let payloadSize = 0;\n      if (this.payloadSizes) {\n        payloadSize = this.payloadSizes.get(command) ?? 0;\n      }\n      const remainingLen = data.length - index;\n      if (remainingLen < payloadSize + 1) {\n        // If remaining length is not long enough for full payload, save the remaining\n        // data until we receive more data. The data has been split up.\n        this.previousBuffer = data.slice(index);\n        break;\n      }\n\n      // Only process if the game is still going\n      if (this.settings.mode === SlpStreamMode.MANUAL && this.gameEnded) {\n        break;\n      }\n\n      // Increment by one for the command byte\n      index += 1;\n\n      const payloadPtr = data.slice(index);\n      const payloadDataView = new DataView(data.buffer, index);\n      let payloadLen = 0;\n      try {\n        payloadLen = this._processCommand(command, payloadPtr, payloadDataView);\n      } catch (err) {\n        // Only throw the error if we're not suppressing the errors\n        if (!this.settings.suppressErrors) {\n          throw err;\n        }\n        payloadLen = 0;\n      }\n      index += payloadLen;\n    }\n\n    callback();\n  }\n\n  private _writeCommand(command: Command, entirePayload: Uint8Array, payloadSize: number): Uint8Array {\n    const payloadBuf = entirePayload.slice(0, payloadSize);\n    const bufToWrite = Buffer.concat([Buffer.from([command]), payloadBuf]);\n    // Forward the raw buffer onwards\n    const event: SlpRawEventPayload = {\n      command: command,\n      payload: bufToWrite,\n    };\n    this.emit(SlpStreamEvent.RAW, event);\n    return new Uint8Array(bufToWrite);\n  }\n\n  private _processCommand(command: Command, entirePayload: Uint8Array, dataView: DataView): number {\n    // Handle the message size command\n    if (command === Command.MESSAGE_SIZES) {\n      const payloadSize = dataView.getUint8(0);\n      // Set the payload sizes\n      this.payloadSizes = processReceiveCommands(dataView);\n      // Emit the raw command event\n      this._writeCommand(command, entirePayload, payloadSize);\n      const eventPayload: SlpCommandEventPayload = {\n        command: command,\n        payload: this.payloadSizes,\n      };\n      this.emit(SlpStreamEvent.COMMAND, eventPayload);\n      return payloadSize;\n    }\n\n    let payloadSize = 0;\n    if (this.payloadSizes) {\n      payloadSize = this.payloadSizes.get(command) ?? 0;\n    }\n\n    // Fetch the payload and parse it\n    let payload: Uint8Array;\n    let parsedPayload: EventPayloadTypes | null = null;\n    if (payloadSize > 0) {\n      payload = this._writeCommand(command, entirePayload, payloadSize);\n      parsedPayload = parseMessage(command, payload);\n    }\n    if (!parsedPayload) {\n      return payloadSize;\n    }\n\n    switch (command) {\n      case Command.GAME_END:\n        // Stop parsing data until we manually restart the stream\n        if (this.settings.mode === SlpStreamMode.MANUAL) {\n          this.gameEnded = true;\n        }\n        break;\n    }\n\n    const eventPayload: SlpCommandEventPayload = {\n      command: command,\n      payload: parsedPayload,\n    };\n    this.emit(SlpStreamEvent.COMMAND, eventPayload);\n    return payloadSize;\n  }\n}\n\nconst processReceiveCommands = (dataView: DataView): MessageSizes => {\n  const payloadSizes = new Map<Command, number>();\n  const payloadLen = dataView.getUint8(0);\n  for (let i = 1; i < payloadLen; i += 3) {\n    const commandByte = dataView.getUint8(i);\n    const payloadSize = dataView.getUint16(i + 1);\n    payloadSizes.set(commandByte, payloadSize);\n  }\n  return payloadSizes;\n};\n","import map from \"lodash/map\";\n\nexport function toHalfwidth(str: string): string {\n  // Converts a fullwidth character to halfwidth\n  const convertChar = (charCode: number): number => {\n    /**\n     * Standard full width encodings\n     * https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)\n     */\n    if (charCode > 0xff00 && charCode < 0xff5f) {\n      return 0x0020 + (charCode - 0xff00);\n    }\n\n    // space:\n    if (charCode === 0x3000) {\n      return 0x0020;\n    }\n\n    /**\n     * Exceptions found in Melee/Japanese keyboards\n     */\n    // single quote: '\n    if (charCode === 0x2019) {\n      return 0x0027;\n    }\n\n    // double quote: \"\n    if (charCode === 0x201d) {\n      return 0x0022;\n    }\n\n    return charCode;\n  };\n\n  const ret = map(str, (char) => convertChar(char.charCodeAt(0)));\n\n  return String.fromCharCode(...ret);\n}\n","import type { WriteStream } from \"fs\";\nimport forEach from \"lodash/forEach\";\nimport type { WritableOptions } from \"stream\";\nimport { Writable } from \"stream\";\n\nimport type { GameStartType, PostFrameUpdateType } from \"../types\";\nimport { Command } from \"../types\";\nimport type { SlpCommandEventPayload } from \"./slpStream\";\nimport { SlpStream, SlpStreamEvent, SlpStreamMode } from \"./slpStream\";\n\nconst DEFAULT_NICKNAME = \"unknown\";\n\nexport type SlpFileMetadata = {\n  startTime: Date;\n  lastFrame: number;\n  players: {\n    [playerIndex: number]: {\n      characterUsage: {\n        [internalCharacterId: number]: number;\n      };\n      names: {\n        netplay: string;\n        code: string;\n      };\n    };\n  };\n  consoleNickname?: string;\n};\n\n/**\n * SlpFile is a class that wraps a Writable stream. It handles the writing of the binary\n * header and footer, and also handles the overwriting of the raw data length.\n *\n * @class SlpFile\n * @extends {Writable}\n */\nexport class SlpFile extends Writable {\n  private filePath: string;\n  private metadata: SlpFileMetadata;\n  private fileStream: WriteStream | null = null;\n  private rawDataLength = 0;\n  private slpStream: SlpStream;\n  private usesExternalStream = false;\n\n  /**\n   * Creates an instance of SlpFile.\n   * @param {string} filePath The file location to write to.\n   * @param {WritableOptions} [opts] Options for writing.\n   * @memberof SlpFile\n   */\n  public constructor(filePath: string, slpStream?: SlpStream, opts?: WritableOptions) {\n    super(opts);\n    this.filePath = filePath;\n    this.metadata = {\n      consoleNickname: DEFAULT_NICKNAME,\n      startTime: new Date(),\n      lastFrame: -124,\n      players: {},\n    };\n    this.usesExternalStream = Boolean(slpStream);\n\n    // Create a new SlpStream if one wasn't already provided\n    // This SLP stream represents a single game not multiple, so use manual mode\n    this.slpStream = slpStream ? slpStream : new SlpStream({ mode: SlpStreamMode.MANUAL });\n\n    this._setupListeners();\n    this._initializeNewGame(this.filePath);\n  }\n\n  /**\n   * Get the current file path being written to.\n   *\n   * @returns {string} The location of the current file path\n   * @memberof SlpFile\n   */\n  public path(): string {\n    return this.filePath;\n  }\n\n  /**\n   * Sets the metadata of the Slippi file, such as consoleNickname, lastFrame, and players.\n   * @param metadata The metadata to be written\n   */\n  public setMetadata(metadata: Partial<SlpFileMetadata>): void {\n    this.metadata = Object.assign({}, this.metadata, metadata);\n  }\n\n  public _write(chunk: Uint8Array, encoding: string, callback: (error?: Error | null) => void): void {\n    if (encoding !== \"buffer\") {\n      throw new Error(`Unsupported stream encoding. Expected 'buffer' got '${encoding}'.`);\n    }\n    // Write it to the file\n    if (this.fileStream) {\n      this.fileStream.write(chunk);\n    }\n\n    // Parse the data manually if it's an internal stream\n    if (!this.usesExternalStream) {\n      this.slpStream.write(chunk);\n    }\n\n    // Keep track of the bytes we've written\n    this.rawDataLength += chunk.length;\n    callback();\n  }\n\n  /**\n   * Here we define what to do on each command. We need to populate the metadata field\n   * so we keep track of the latest frame, as well as the number of frames each character has\n   * been used.\n   *\n   * @param data The parsed data from a SlpStream\n   */\n  private _onCommand(data: SlpCommandEventPayload): void {\n    const { command, payload } = data;\n    switch (command) {\n      case Command.GAME_START:\n        const { players } = payload as GameStartType;\n        forEach(players, (player) => {\n          if (player.type === 3) {\n            return;\n          }\n\n          this.metadata.players[player.playerIndex] = {\n            characterUsage: {},\n            names: {\n              netplay: player.displayName,\n              code: player.connectCode,\n            },\n          };\n        });\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // Here we need to update some metadata fields\n        const { frame, playerIndex, isFollower, internalCharacterId } = payload as PostFrameUpdateType;\n        if (isFollower) {\n          // No need to do this for follower\n          break;\n        }\n\n        // Update frame index\n        this.metadata.lastFrame = frame!;\n\n        // Update character usage\n        const prevPlayer = this.metadata.players[playerIndex!];\n        const characterUsage = prevPlayer!.characterUsage;\n        const curCharFrames = characterUsage[internalCharacterId!] || 0;\n        const player = {\n          ...prevPlayer,\n          characterUsage: {\n            ...characterUsage,\n            [internalCharacterId!]: curCharFrames + 1,\n          },\n        };\n        (this.metadata.players as any)[playerIndex!] = player;\n        break;\n    }\n  }\n\n  private _setupListeners(): void {\n    const streamListener = (data: SlpCommandEventPayload): void => {\n      this._onCommand(data);\n    };\n    this.slpStream.on(SlpStreamEvent.COMMAND, streamListener);\n\n    this.on(\"finish\", () => {\n      // Update file with bytes written\n      console.error(\"removed stuff here for cloudflare worker support\");\n\n      // Unsubscribe from the stream\n      this.slpStream.removeListener(SlpStreamEvent.COMMAND, streamListener);\n      // Terminate the internal stream\n      if (!this.usesExternalStream) {\n        this.slpStream.end();\n      }\n    });\n  }\n\n  private _initializeNewGame(filePath: string): void {\n    console.error(\"removed stuff here for cloudflare worker support\");\n  }\n\n  public _final(callback: (error?: Error | null) => void): void {\n    let footer = Buffer.concat([Buffer.from(\"U\"), Buffer.from([8]), Buffer.from(\"metadata{\")]);\n\n    // Write game start time\n    const startTimeStr = this.metadata.startTime.toISOString();\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([7]),\n      Buffer.from(\"startAtSU\"),\n      Buffer.from([startTimeStr.length]),\n      Buffer.from(startTimeStr),\n    ]);\n\n    // Write last frame index\n    // TODO: Get last frame\n    const lastFrame = this.metadata.lastFrame;\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([9]),\n      Buffer.from(\"lastFramel\"),\n      createInt32Buffer(lastFrame),\n    ]);\n\n    // write the Console Nickname\n    const consoleNick = this.metadata.consoleNickname || DEFAULT_NICKNAME;\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([11]),\n      Buffer.from(\"consoleNickSU\"),\n      Buffer.from([consoleNick.length]),\n      Buffer.from(consoleNick),\n    ]);\n\n    // Start writting player specific data\n    footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([7]), Buffer.from(\"players{\")]);\n    const players = this.metadata.players;\n    forEach(players, (player, index) => {\n      // Start player obj with index being the player index\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([index.length]), Buffer.from(`${index}{`)]);\n\n      // Start characters key for this player\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([10]), Buffer.from(\"characters{\")]);\n\n      // Write character usage\n      forEach(player.characterUsage, (usage, internalId) => {\n        // Write this character\n        footer = Buffer.concat([\n          footer,\n          Buffer.from(\"U\"),\n          Buffer.from([internalId.length]),\n          Buffer.from(`${internalId}l`),\n          createUInt32Buffer(usage),\n        ]);\n      });\n\n      // Close characters\n      footer = Buffer.concat([footer, Buffer.from(\"}\")]);\n\n      // Start names key for this player\n      footer = Buffer.concat([footer, Buffer.from(\"U\"), Buffer.from([5]), Buffer.from(\"names{\")]);\n\n      // Write display name\n      footer = Buffer.concat([\n        footer,\n        Buffer.from(\"U\"),\n        Buffer.from([7]),\n        Buffer.from(\"netplaySU\"),\n        Buffer.from([player.names.netplay.length]),\n        Buffer.from(`${player.names.netplay}`),\n      ]);\n\n      // Write connect code\n      footer = Buffer.concat([\n        footer,\n        Buffer.from(\"U\"),\n        Buffer.from([4]),\n        Buffer.from(\"codeSU\"),\n        Buffer.from([player.names.code.length]),\n        Buffer.from(`${player.names.code}`),\n      ]);\n\n      // Close names and player\n      footer = Buffer.concat([footer, Buffer.from(\"}}\")]);\n    });\n\n    // Close players\n    footer = Buffer.concat([footer, Buffer.from(\"}\")]);\n\n    // Write played on\n    footer = Buffer.concat([\n      footer,\n      Buffer.from(\"U\"),\n      Buffer.from([8]),\n      Buffer.from(\"playedOnSU\"),\n      Buffer.from([7]),\n      Buffer.from(\"network\"),\n    ]);\n\n    // Close metadata and file\n    footer = Buffer.concat([footer, Buffer.from(\"}}\")]);\n\n    // End the stream\n    if (this.fileStream) {\n      this.fileStream.write(footer, callback);\n    }\n  }\n}\n\nconst createInt32Buffer = (number: number): Buffer => {\n  const buf = Buffer.alloc(4);\n  buf.writeInt32BE(number, 0);\n  return buf;\n};\n\nconst createUInt32Buffer = (number: number): Buffer => {\n  const buf = Buffer.alloc(4);\n  buf.writeUInt32BE(number, 0);\n  return buf;\n};\n","import { format } from \"date-fns\";\nimport path from \"path\";\nimport type { WritableOptions } from \"stream\";\n\nimport { Command } from \"../types\";\nimport { SlpFile } from \"./slpFile\";\nimport type { SlpRawEventPayload, SlpStreamSettings } from \"./slpStream\";\nimport { SlpStream, SlpStreamEvent } from \"./slpStream\";\n\n/**\n * The default function to use for generating new SLP files.\n */\nfunction getNewFilePath(folder: string, date: Date): string {\n  return path.join(folder, `Game_${format(date, \"yyyyMMdd\")}T${format(date, \"HHmmss\")}.slp`);\n}\n\nexport type SlpFileWriterOptions = Partial<SlpStreamSettings> & {\n  outputFiles: boolean;\n  folderPath: string;\n  consoleNickname: string;\n  newFilename: (folder: string, startTime: Date) => string;\n};\n\nconst defaultSettings: SlpFileWriterOptions = {\n  outputFiles: true,\n  folderPath: \".\",\n  consoleNickname: \"unknown\",\n  newFilename: getNewFilePath,\n};\n\nexport enum SlpFileWriterEvent {\n  NEW_FILE = \"new-file\",\n  FILE_COMPLETE = \"file-complete\",\n}\n\n/**\n * SlpFileWriter lets us not only emit events as an SlpStream but also\n * writes the data that is being passed in to an SLP file. Use this if\n * you want to process Slippi data in real time but also want to be able\n * to write out the data to an SLP file.\n *\n * @export\n * @class SlpFileWriter\n * @extends {SlpStream}\n */\nexport class SlpFileWriter extends SlpStream {\n  private currentFile: SlpFile | null = null;\n  private options: SlpFileWriterOptions;\n\n  /**\n   * Creates an instance of SlpFileWriter.\n   */\n  public constructor(options?: Partial<SlpFileWriterOptions>, opts?: WritableOptions) {\n    super(options, opts);\n    this.options = Object.assign({}, defaultSettings, options);\n    this._setupListeners();\n  }\n\n  private _writePayload(payload: Buffer): void {\n    // Write data to the current file\n    if (this.currentFile) {\n      this.currentFile.write(payload);\n    }\n  }\n\n  private _setupListeners(): void {\n    this.on(SlpStreamEvent.RAW, (data: SlpRawEventPayload) => {\n      const { command, payload } = data;\n      switch (command) {\n        case Command.MESSAGE_SIZES:\n          // Create the new game first before writing the payload\n          this._handleNewGame();\n          this._writePayload(payload);\n          break;\n        case Command.GAME_END:\n          // Write payload first before ending the game\n          this._writePayload(payload);\n          this._handleEndGame();\n          break;\n        default:\n          this._writePayload(payload);\n          break;\n      }\n    });\n  }\n\n  /**\n   * Return the name of the SLP file currently being written or null if\n   * no file is being written to currently.\n   *\n   * @returns {(string | null)}\n   * @memberof SlpFileWriter\n   */\n  public getCurrentFilename(): string | null {\n    if (this.currentFile !== null) {\n      return path.resolve(this.currentFile.path());\n    }\n    return null;\n  }\n\n  /**\n   * Ends the current file being written to.\n   *\n   * @returns {(string | null)}\n   * @memberof SlpFileWriter\n   */\n  public endCurrentFile(): void {\n    this._handleEndGame();\n  }\n\n  /**\n   * Updates the settings to be the desired ones passed in.\n   *\n   * @param {Partial<SlpFileWriterOptions>} settings\n   * @memberof SlpFileWriter\n   */\n  public updateSettings(settings: Partial<SlpFileWriterOptions>): void {\n    this.options = Object.assign({}, this.options, settings);\n  }\n\n  private _handleNewGame(): void {\n    // Only create a new file if we're outputting files\n    if (this.options.outputFiles) {\n      const filePath = this.options.newFilename(this.options.folderPath, new Date());\n      this.currentFile = new SlpFile(filePath, this);\n      // console.log(`Creating new file at: ${filePath}`);\n      this.emit(SlpFileWriterEvent.NEW_FILE, filePath);\n    }\n  }\n\n  private _handleEndGame(): void {\n    // End the stream\n    if (this.currentFile) {\n      // Set the console nickname\n      this.currentFile.setMetadata({\n        consoleNickname: this.options.consoleNickname,\n      });\n      this.currentFile.end();\n\n      // console.log(`Finished writing file: ${this.currentFile.path()}`);\n      this.emit(SlpFileWriterEvent.FILE_COMPLETE, this.currentFile.path());\n\n      // Clear current file\n      this.currentFile = null;\n    }\n  }\n}\n","import { EventEmitter } from \"events\";\nimport get from \"lodash/get\";\nimport keyBy from \"lodash/keyBy\";\nimport set from \"lodash/set\";\nimport semver from \"semver\";\n\nimport type {\n  EnabledItemType,\n  FrameBookendType,\n  FrameEntryType,\n  FrameStartType,\n  FramesType,\n  GameEndType,\n  GameStartType,\n  GeckoListType,\n  ItemUpdateType,\n  PostFrameUpdateType,\n  PreFrameUpdateType,\n  RollbackFrames,\n} from \"../types\";\nimport { ItemSpawnType } from \"../types\";\nimport { Command, Frames, GameMode } from \"../types\";\nimport { exists } from \"./exists\";\nimport { RollbackCounter } from \"./rollbackCounter\";\n\n// There are 5 bytes of item bitfields that can be enabled\nconst ITEM_SETTINGS_BIT_COUNT = 40;\nexport const MAX_ROLLBACK_FRAMES = 7;\n\nexport enum SlpParserEvent {\n  SETTINGS = \"settings\",\n  END = \"end\",\n  FRAME = \"frame\", // Emitted for every frame\n  FINALIZED_FRAME = \"finalized-frame\", // Emitted for only finalized frames\n  ROLLBACK_FRAME = \"rollback-frame\", // Emitted if a frame is being replaced\n}\n\n// If strict mode is on, we will do strict validation checking\n// which could throw errors on invalid data.\n// Default to false though since probably only real time applications\n// would care about valid data.\nconst defaultSlpParserOptions = {\n  strict: false,\n};\n\nexport type SlpParserOptions = typeof defaultSlpParserOptions;\n\nexport class SlpParser extends EventEmitter {\n  private frames: FramesType = {};\n  private rollbackCounter: RollbackCounter = new RollbackCounter();\n  private settings: GameStartType | null = null;\n  private gameEnd: GameEndType | null = null;\n  private latestFrameIndex: number | null = null;\n  private settingsComplete = false;\n  private lastFinalizedFrame = Frames.FIRST - 1;\n  private options: SlpParserOptions;\n  private geckoList: GeckoListType | null = null;\n\n  public constructor(options?: Partial<SlpParserOptions>) {\n    super();\n    this.options = Object.assign({}, defaultSlpParserOptions, options);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public handleCommand(command: Command, payload: any): void {\n    switch (command) {\n      case Command.GAME_START:\n        this._handleGameStart(payload as GameStartType);\n        break;\n      case Command.FRAME_START:\n        this._handleFrameStart(payload as FrameStartType);\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // We need to handle the post frame update first since that\n        // will finalize the settings object, before we fire the frame update\n        this._handlePostFrameUpdate(payload as PostFrameUpdateType);\n        this._handleFrameUpdate(command, payload as PostFrameUpdateType);\n        break;\n      case Command.PRE_FRAME_UPDATE:\n        this._handleFrameUpdate(command, payload as PreFrameUpdateType);\n        break;\n      case Command.ITEM_UPDATE:\n        this._handleItemUpdate(payload as ItemUpdateType);\n        break;\n      case Command.FRAME_BOOKEND:\n        this._handleFrameBookend(payload as FrameBookendType);\n        break;\n      case Command.GAME_END:\n        this._handleGameEnd(payload as GameEndType);\n        break;\n      case Command.GECKO_LIST:\n        this._handleGeckoList(payload as GeckoListType);\n        break;\n    }\n  }\n\n  /**\n   * Resets the parser state to their default values.\n   */\n  public reset(): void {\n    this.frames = {};\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = Frames.FIRST - 1;\n  }\n\n  public getLatestFrameNumber(): number {\n    return this.latestFrameIndex ?? Frames.FIRST - 1;\n  }\n\n  public getPlayableFrameCount(): number {\n    if (this.latestFrameIndex === null) {\n      return 0;\n    }\n    return this.latestFrameIndex < Frames.FIRST_PLAYABLE ? 0 : this.latestFrameIndex - Frames.FIRST_PLAYABLE;\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    // return this.playerFrames[this.latestFrameIndex];\n\n    // TODO: Modify this to check if we actually have all the latest frame data and return that\n    // TODO: If we do. For now I'm just going to take a shortcut\n    const allFrames = this.getFrames();\n    const frameIndex = this.latestFrameIndex !== null ? this.latestFrameIndex : Frames.FIRST;\n    const indexToUse = this.gameEnd ? frameIndex : frameIndex - 1;\n    return get(allFrames, indexToUse) || null;\n  }\n\n  public getSettings(): GameStartType | null {\n    return this.settingsComplete ? this.settings : null;\n  }\n\n  public getItems(): EnabledItemType[] | null {\n    if (this.settings?.itemSpawnBehavior === ItemSpawnType.OFF) {\n      return null;\n    }\n\n    const itemBitfield = this.settings?.enabledItems;\n    if (!exists(itemBitfield)) {\n      return null;\n    }\n\n    const enabledItems: EnabledItemType[] = [];\n\n    // Ideally we would be able to do this with bitshifting instead, but javascript\n    // truncates numbers after 32 bits when doing bitwise operations\n    for (let i = 0; i < ITEM_SETTINGS_BIT_COUNT; i++) {\n      if (Math.floor(itemBitfield / 2 ** i) & 1) {\n        enabledItems.push(2 ** i);\n      }\n    }\n\n    return enabledItems;\n  }\n\n  public getGameEnd(): GameEndType | null {\n    return this.gameEnd;\n  }\n\n  public getFrames(): FramesType {\n    return this.frames;\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    return {\n      frames: this.rollbackCounter.getFrames(),\n      count: this.rollbackCounter.getCount(),\n      lengths: this.rollbackCounter.getLengths(),\n    };\n  }\n\n  public getFrame(num: number): FrameEntryType | null {\n    return this.frames[num] || null;\n  }\n\n  public getGeckoList(): GeckoListType | null {\n    return this.geckoList;\n  }\n\n  private _handleGeckoList(payload: GeckoListType): void {\n    this.geckoList = payload;\n  }\n\n  private _handleGameEnd(payload: GameEndType): void {\n    // Finalize remaining frames if necessary\n    if (this.latestFrameIndex !== null && this.latestFrameIndex !== this.lastFinalizedFrame) {\n      this._finalizeFrames(this.latestFrameIndex);\n    }\n\n    this.gameEnd = payload;\n    this.emit(SlpParserEvent.END, this.gameEnd);\n  }\n\n  private _handleGameStart(payload: GameStartType): void {\n    this.settings = payload;\n    const players = payload.players;\n    this.settings.players = players.filter((player) => player.type !== 3);\n\n    // Check to see if the file was created after the sheik fix so we know\n    // we don't have to process the first frame of the game for the full settings\n    if (payload.slpVersion && semver.gte(payload.slpVersion, \"1.6.0\")) {\n      this._completeSettings();\n    }\n  }\n\n  private _handleFrameStart(payload: FrameStartType): void {\n    const currentFrameNumber = payload.frame!;\n\n    set(this.frames, [currentFrameNumber, \"start\"], payload);\n  }\n\n  private _handlePostFrameUpdate(payload: PostFrameUpdateType): void {\n    if (this.settingsComplete) {\n      return;\n    }\n\n    // Finish calculating settings\n    if (payload.frame! <= Frames.FIRST) {\n      const playerIndex = payload.playerIndex!;\n      const playersByIndex = keyBy(this.settings!.players, \"playerIndex\");\n\n      switch (payload.internalCharacterId) {\n        case 0x7:\n          playersByIndex[playerIndex]!.characterId = 0x13; // Sheik\n          break;\n        case 0x13:\n          playersByIndex[playerIndex]!.characterId = 0x12; // Zelda\n          break;\n      }\n    }\n    if (payload.frame! > Frames.FIRST) {\n      this._completeSettings();\n    }\n  }\n\n  private _handleFrameUpdate(command: Command, payload: PreFrameUpdateType | PostFrameUpdateType): void {\n    const location = command === Command.PRE_FRAME_UPDATE ? \"pre\" : \"post\";\n    const field = payload.isFollower ? \"followers\" : \"players\";\n    const currentFrameNumber = payload.frame!;\n    this.latestFrameIndex = currentFrameNumber;\n    if (location === \"pre\" && !payload.isFollower) {\n      const currentFrame = this.frames[currentFrameNumber];\n      const wasRolledback = this.rollbackCounter.checkIfRollbackFrame(currentFrame, payload.playerIndex!);\n      if (wasRolledback) {\n        // frame is about to be overwritten\n        this.emit(SlpParserEvent.ROLLBACK_FRAME, currentFrame);\n      }\n    }\n    set(this.frames, [currentFrameNumber, field, payload.playerIndex!, location], payload);\n    set(this.frames, [currentFrameNumber, \"frame\"], currentFrameNumber);\n\n    // If file is from before frame bookending, add frame to stats computer here. Does a little\n    // more processing than necessary, but it works\n    const settings = this.getSettings();\n    if (settings && (!settings.slpVersion || semver.lte(settings.slpVersion, \"2.2.0\"))) {\n      this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n      // Finalize the previous frame since no bookending exists\n      this._finalizeFrames(currentFrameNumber - 1);\n    } else {\n      set(this.frames, [currentFrameNumber, \"isTransferComplete\"], false);\n    }\n  }\n\n  private _handleItemUpdate(payload: ItemUpdateType): void {\n    const currentFrameNumber = payload.frame!;\n    const items = this.frames[currentFrameNumber]?.items ?? [];\n    items.push(payload);\n\n    // Set items with newest\n    set(this.frames, [currentFrameNumber, \"items\"], items);\n  }\n\n  private _handleFrameBookend(payload: FrameBookendType): void {\n    const latestFinalizedFrame = payload.latestFinalizedFrame!;\n    const currentFrameNumber = payload.frame!;\n    set(this.frames, [currentFrameNumber, \"isTransferComplete\"], true);\n    // Fire off a normal frame event\n    this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n\n    // Finalize frames if necessary\n    const validLatestFrame = this.settings!.gameMode === GameMode.ONLINE;\n    if (validLatestFrame && latestFinalizedFrame >= Frames.FIRST) {\n      // Ensure valid latestFinalizedFrame\n      if (this.options.strict && latestFinalizedFrame < currentFrameNumber - MAX_ROLLBACK_FRAMES) {\n        throw new Error(`latestFinalizedFrame should be within ${MAX_ROLLBACK_FRAMES} frames of ${currentFrameNumber}`);\n      }\n      this._finalizeFrames(latestFinalizedFrame);\n    } else {\n      // Since we don't have a valid finalized frame, just finalize the frame based on MAX_ROLLBACK_FRAMES\n      this._finalizeFrames(currentFrameNumber - MAX_ROLLBACK_FRAMES);\n    }\n  }\n\n  /**\n   * Fires off the FINALIZED_FRAME event for frames up until a certain number\n   * @param num The frame to finalize until\n   */\n  private _finalizeFrames(num: number): void {\n    while (this.lastFinalizedFrame < num) {\n      const frameToFinalize = this.lastFinalizedFrame + 1;\n      const frame = this.getFrame(frameToFinalize)!;\n\n      // Check that we have all the pre and post frame data for all players if we're in strict mode\n      if (this.options.strict) {\n        for (const player of this.settings!.players) {\n          const playerFrameInfo = frame.players[player.playerIndex];\n          // Allow player frame info to be empty in non 1v1 games since\n          // players which have been defeated will have no frame info.\n          if (this.settings!.players.length > 2 && !playerFrameInfo) {\n            continue;\n          }\n\n          const { pre, post } = playerFrameInfo!;\n          if (!pre || !post) {\n            const preOrPost = pre ? \"pre\" : \"post\";\n            throw new Error(\n              `Could not finalize frame ${frameToFinalize} of ${num}: missing ${preOrPost}-frame update for player ${player.playerIndex}`,\n            );\n          }\n        }\n      }\n\n      // Our frame is complete so finalize the frame\n      this.emit(SlpParserEvent.FINALIZED_FRAME, frame);\n      this.lastFinalizedFrame = frameToFinalize;\n    }\n  }\n\n  private _completeSettings(): void {\n    if (!this.settingsComplete) {\n      this.settingsComplete = true;\n      this.emit(SlpParserEvent.SETTINGS, this.settings);\n    }\n  }\n}\n","import type { FrameEntryType, RollbackFramesType } from \"../types\";\n\nexport class RollbackCounter {\n  private rollbackFrames: RollbackFramesType = {};\n  private rollbackFrameCount = 0;\n  private rollbackPlayerIdx: number | null = null; // for keeping track of rollbacks by following a single player\n  private lastFrameWasRollback = false;\n  private currentRollbackLength = 0;\n  private rollbackLengths: number[] = [];\n\n  public checkIfRollbackFrame(currentFrame: FrameEntryType | undefined, playerIdx: number) {\n    if (this.rollbackPlayerIdx === null) {\n      // we only want to follow a single player to avoid double counting. So we use whoever is on first.\n      this.rollbackPlayerIdx = playerIdx;\n    } else if (this.rollbackPlayerIdx !== playerIdx) {\n      return;\n    }\n\n    if (currentFrame && currentFrame.players) {\n      // frame already exists for currentFrameNumber so we must be rolling back\n      // Note: We detect during PreFrameUpdate, but new versions have a\n      // FrameStart command that has already initialized the frame, so we must\n      // check for player data too.\n      if (this.rollbackFrames[currentFrame.frame]) {\n        this.rollbackFrames[currentFrame.frame]!.push(currentFrame);\n      } else {\n        this.rollbackFrames[currentFrame.frame] = [currentFrame];\n      }\n      this.rollbackFrameCount++;\n      this.currentRollbackLength++;\n      this.lastFrameWasRollback = true;\n    } else if (this.lastFrameWasRollback) {\n      this.rollbackLengths.push(this.currentRollbackLength);\n      this.currentRollbackLength = 0;\n      this.lastFrameWasRollback = false;\n    }\n    return this.lastFrameWasRollback;\n  }\n\n  public getFrames() {\n    return this.rollbackFrames;\n  }\n\n  public getCount() {\n    return this.rollbackFrameCount;\n  }\n\n  public getLengths() {\n    return this.rollbackLengths;\n  }\n}\n","import type { StadiumStatsType, StatOptions, StatsType } from \"./stats\";\nimport { TargetBreakComputer } from \"./stats\";\nimport {\n  ActionsComputer,\n  ComboComputer,\n  ConversionComputer,\n  generateOverallStats,\n  InputComputer,\n  Stats,\n  StockComputer,\n} from \"./stats\";\nimport type {\n  EnabledItemType,\n  EventCallbackFunc,\n  FrameEntryType,\n  FramesType,\n  GameEndType,\n  GameStartType,\n  GeckoListType,\n  MetadataType,\n  PlacementType,\n  PostFrameUpdateType,\n  RollbackFrames,\n} from \"./types\";\nimport { GameEndMethod, GameMode } from \"./types\";\nimport { getWinners } from \"./utils/getWinners\";\nimport { extractDistanceInfoFromFrame } from \"./utils/homeRunDistance\";\nimport { SlpParser, SlpParserEvent } from \"./utils/slpParser\";\nimport type { SlpFileType, SlpReadInput } from \"./utils/slpReader\";\nimport {\n  closeSlpFile,\n  extractFinalPostFrameUpdates,\n  getGameEnd,\n  getMetadata,\n  iterateEvents,\n  openSlpFile,\n  SlpInputSource,\n} from \"./utils/slpReader\";\n\n/**\n * Slippi Game class that wraps a file\n */\nexport class SlippiGame {\n  private input: SlpReadInput;\n  private metadata: MetadataType | null = null;\n  private finalStats: StatsType | null = null;\n  private parser: SlpParser;\n  private readPosition: number | null = null;\n  private actionsComputer: ActionsComputer = new ActionsComputer();\n  private conversionComputer: ConversionComputer = new ConversionComputer();\n  private comboComputer: ComboComputer = new ComboComputer();\n  private stockComputer: StockComputer = new StockComputer();\n  private inputComputer: InputComputer = new InputComputer();\n  private targetBreakComputer: TargetBreakComputer = new TargetBreakComputer();\n  protected statsComputer: Stats;\n\n  public constructor(input: string | Buffer | ArrayBuffer, opts?: StatOptions) {\n    if (typeof input === \"string\") {\n      this.input = {\n        source: SlpInputSource.FILE,\n        filePath: input,\n      };\n    } else if (input instanceof Buffer) {\n      this.input = {\n        source: SlpInputSource.BUFFER,\n        buffer: input,\n      };\n    } else if (input instanceof ArrayBuffer) {\n      this.input = {\n        source: SlpInputSource.BUFFER,\n        buffer: Buffer.from(input),\n      };\n    } else {\n      throw new Error(\"Cannot create SlippiGame with input of that type\");\n    }\n\n    // Set up stats calculation\n    this.statsComputer = new Stats(opts);\n    this.statsComputer.register(\n      this.actionsComputer,\n      this.comboComputer,\n      this.conversionComputer,\n      this.inputComputer,\n      this.stockComputer,\n      this.targetBreakComputer,\n    );\n\n    this.parser = new SlpParser();\n    this.parser.on(SlpParserEvent.SETTINGS, (settings) => {\n      this.statsComputer.setup(settings);\n    });\n\n    // Use finalized frames for stats computation\n    this.parser.on(SlpParserEvent.FINALIZED_FRAME, (frame: FrameEntryType) => {\n      this.statsComputer.addFrame(frame);\n    });\n  }\n\n  private _process(shouldStop: EventCallbackFunc = () => false, file?: SlpFileType): void {\n    if (this.parser.getGameEnd() !== null) {\n      return;\n    }\n    const slpfile = file ?? openSlpFile(this.input);\n    // Generate settings from iterating through file\n    this.readPosition = iterateEvents(\n      slpfile,\n      (command, payload) => {\n        if (!payload) {\n          // If payload is falsy, keep iterating. The parser probably just doesn't know\n          // about this command yet\n          return false;\n        }\n        this.parser.handleCommand(command, payload);\n        return shouldStop(command, payload);\n      },\n      this.readPosition,\n    );\n    if (!file) {\n      closeSlpFile(slpfile);\n    }\n  }\n\n  /**\n   * Gets the game settings, these are the settings that describe the starting state of\n   * the game such as characters, stage, etc.\n   */\n  public getSettings(): GameStartType | null {\n    // Settings is only complete after post-frame update\n    this._process(() => this.parser.getSettings() !== null);\n    return this.parser.getSettings();\n  }\n\n  public getItems(): EnabledItemType[] | null {\n    this._process();\n    return this.parser.getItems();\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    this._process();\n    return this.parser.getLatestFrame();\n  }\n\n  public getGameEnd(options: { skipProcessing?: boolean } = {}): GameEndType | null {\n    if (options?.skipProcessing) {\n      // Read game end block directly\n      const slpfile = openSlpFile(this.input);\n      const gameEnd = getGameEnd(slpfile);\n      closeSlpFile(slpfile);\n      return gameEnd;\n    }\n\n    this._process();\n    return this.parser.getGameEnd();\n  }\n\n  public getFrames(): FramesType {\n    this._process();\n    return this.parser.getFrames();\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    this._process();\n    return this.parser.getRollbackFrames();\n  }\n\n  public getGeckoList(): GeckoListType | null {\n    this._process(() => this.parser.getGeckoList() !== null);\n    return this.parser.getGeckoList();\n  }\n\n  public getStats(): StatsType | null {\n    if (this.finalStats) {\n      return this.finalStats;\n    }\n\n    this._process();\n\n    const settings = this.parser.getSettings();\n    if (!settings) {\n      return null;\n    }\n\n    // Finish processing if we're not up to date\n    this.statsComputer.process();\n    const inputs = this.inputComputer.fetch();\n    const stocks = this.stockComputer.fetch();\n    const conversions = this.conversionComputer.fetch();\n    const playableFrameCount = this.parser.getPlayableFrameCount();\n    const overall = generateOverallStats({ settings, inputs, conversions, playableFrameCount });\n\n    const gameEnd = this.parser.getGameEnd();\n    const gameComplete = gameEnd !== null;\n\n    const stats: StatsType = {\n      lastFrame: this.parser.getLatestFrameNumber(),\n      playableFrameCount,\n      stocks: stocks,\n      conversions: conversions,\n      combos: this.comboComputer.fetch(),\n      actionCounts: this.actionsComputer.fetch(),\n      overall: overall,\n      gameComplete,\n    };\n\n    if (gameComplete) {\n      // If the game is complete, store a cached version of stats because it should not\n      // change anymore. Ideally the statsCompuer.process and fetch functions would simply do no\n      // work in this case instead but currently the conversions fetch function,\n      // generateOverallStats, and maybe more are doing work on every call.\n      this.finalStats = stats;\n    }\n\n    return stats;\n  }\n\n  public getStadiumStats(): StadiumStatsType | null {\n    this._process();\n\n    const settings = this.parser.getSettings();\n    if (!settings) {\n      return null;\n    }\n\n    const latestFrame = this.parser.getLatestFrame();\n    const players = latestFrame?.players;\n\n    if (!players) {\n      return null;\n    }\n\n    this.statsComputer.process();\n\n    switch (settings.gameMode) {\n      case GameMode.TARGET_TEST:\n        return {\n          type: \"target-test\",\n          targetBreaks: this.targetBreakComputer.fetch(),\n        };\n      case GameMode.HOME_RUN_CONTEST:\n        const distanceInfo = extractDistanceInfoFromFrame(settings, latestFrame);\n        if (!distanceInfo) {\n          return null;\n        }\n\n        return {\n          type: \"home-run-contest\",\n          distance: distanceInfo.distance,\n          units: distanceInfo.units,\n        };\n      default:\n        return null;\n    }\n  }\n\n  public getMetadata(): MetadataType | null {\n    if (this.metadata) {\n      return this.metadata;\n    }\n    const slpfile = openSlpFile(this.input);\n    this.metadata = getMetadata(slpfile);\n    closeSlpFile(slpfile);\n    return this.metadata;\n  }\n\n  public getFilePath(): string | null {\n    if (this.input.source !== SlpInputSource.FILE) {\n      return null;\n    }\n\n    return this.input.filePath ?? null;\n  }\n\n  public getWinners(): PlacementType[] {\n    // Read game end block directly\n    const slpfile = openSlpFile(this.input);\n    const gameEnd = getGameEnd(slpfile);\n    this._process(() => this.parser.getSettings() !== null, slpfile);\n    const settings = this.parser.getSettings();\n    if (!gameEnd || !settings) {\n      // Technically using the final post frame updates, it should be possible to compute winners for\n      // replays without a gameEnd message. But I'll leave this here anyway\n      closeSlpFile(slpfile);\n      return [];\n    }\n\n    // If we went to time, let's fetch the post frame updates to compute the winner\n    let finalPostFrameUpdates: PostFrameUpdateType[] = [];\n    if (gameEnd.gameEndMethod === GameEndMethod.TIME) {\n      finalPostFrameUpdates = extractFinalPostFrameUpdates(slpfile);\n    }\n\n    closeSlpFile(slpfile);\n    return getWinners(gameEnd, settings, finalPostFrameUpdates);\n  }\n}\n","import type { FrameEntryType, GameStartType } from \"../types\";\nimport { Language } from \"../types\";\nimport { exists } from \"./exists\";\n\nconst SANDBAG_INTERNAL_ID = 32;\n\nconst FEET_CONVERSION_FACTOR = 0.952462;\nconst METERS_CONVERSION_FACTOR = 1.04167;\n\ntype HomeRunDistanceUnits = \"feet\" | \"meters\";\n\nexport function positionToHomeRunDistance(distance: number, units: HomeRunDistanceUnits = \"feet\"): number {\n  let score = 0;\n  switch (units) {\n    case \"feet\":\n      score = 10 * Math.floor(distance - 70 * FEET_CONVERSION_FACTOR);\n      // convert to float32\n      score = Math.fround(score);\n      score = Math.floor((score / 30.4788) * 10) / 10;\n      break;\n    case \"meters\":\n      score = 10 * Math.floor(distance - 70 * METERS_CONVERSION_FACTOR);\n      // convert to float32\n      score = Math.fround(score);\n      score = Math.floor((score / 100) * 10) / 10;\n      break;\n    default:\n      throw new Error(`Unsupported units: ${units}`);\n  }\n\n  // round to 1 decimal\n  score = Math.round(score * 10) / 10;\n  return Math.max(0, score);\n}\n\nexport function extractDistanceInfoFromFrame(\n  settings: Pick<GameStartType, \"language\">,\n  lastFrame: Pick<FrameEntryType, \"players\">,\n): { distance: number; units: HomeRunDistanceUnits } | null {\n  const sandbagLastFrame = Object.values(lastFrame.players)\n    .filter(exists)\n    .find((playerFrame) => playerFrame.post.internalCharacterId === SANDBAG_INTERNAL_ID);\n\n  if (!sandbagLastFrame) {\n    return null;\n  }\n\n  // Only return the distance in meters if it's a Japanese replay.\n  // Technically we should check if the replay is PAL but we don't yet support\n  // stadium replays in PAL.\n  const units: HomeRunDistanceUnits = settings.language === Language.JAPANESE ? \"meters\" : \"feet\";\n  const distance = positionToHomeRunDistance(sandbagLastFrame.post.positionX ?? 0, units);\n  return {\n    distance,\n    units,\n  };\n}\n","import type { GameEndType, GameStartType, PlacementType, PostFrameUpdateType } from \"../types\";\nimport { GameEndMethod } from \"../types\";\nimport { exists } from \"./exists\";\n\nexport function getWinners(\n  gameEnd: GameEndType,\n  settings: Pick<GameStartType, \"players\" | \"isTeams\">,\n  finalPostFrameUpdates: PostFrameUpdateType[],\n): PlacementType[] {\n  const { placements, gameEndMethod, lrasInitiatorIndex } = gameEnd;\n  const { players, isTeams } = settings;\n\n  if (gameEndMethod === GameEndMethod.NO_CONTEST || gameEndMethod === GameEndMethod.UNRESOLVED) {\n    // The winner is the person who didn't LRAS\n    if (exists(lrasInitiatorIndex) && players.length === 2) {\n      const winnerIndex = players.find(({ playerIndex }) => playerIndex !== lrasInitiatorIndex)?.playerIndex;\n      if (exists(winnerIndex)) {\n        return [\n          {\n            playerIndex: winnerIndex,\n            position: 0,\n          },\n        ];\n      }\n    }\n\n    return [];\n  }\n\n  if (gameEndMethod === GameEndMethod.TIME && players.length === 2) {\n    const nonFollowerUpdates = finalPostFrameUpdates.filter((pfu) => !pfu.isFollower);\n    if (nonFollowerUpdates.length !== players.length) {\n      return [];\n    }\n\n    const p1 = nonFollowerUpdates[0]!;\n    const p2 = nonFollowerUpdates[1]!;\n    if (p1.stocksRemaining! > p2.stocksRemaining!) {\n      return [{ playerIndex: p1.playerIndex!, position: 0 }];\n    } else if (p2.stocksRemaining! > p1.stocksRemaining!) {\n      return [{ playerIndex: p2.playerIndex!, position: 0 }];\n    }\n\n    const p1Health = Math.trunc(p1.percent!);\n    const p2Health = Math.trunc(p2.percent!);\n    if (p1Health < p2Health) {\n      return [{ playerIndex: p1.playerIndex!, position: 0 }];\n    } else if (p2Health < p1Health) {\n      return [{ playerIndex: p2.playerIndex!, position: 0 }];\n    }\n\n    // If stocks and percents were tied, no winner\n    return [];\n  }\n\n  const firstPosition = placements.find((placement) => placement.position === 0);\n  if (!firstPosition) {\n    return [];\n  }\n\n  const winningTeam = players.find(({ playerIndex }) => playerIndex === firstPosition.playerIndex)?.teamId ?? null;\n  if (isTeams && exists(winningTeam)) {\n    return placements.filter((placement) => {\n      const teamId = players.find(({ playerIndex }) => playerIndex === placement.playerIndex)?.teamId ?? null;\n      return teamId === winningTeam;\n    });\n  }\n\n  return [firstPosition];\n}\n","// eslint-disable-next-line\nexport function getDeathDirection(actionStateId: number) {\n  if (actionStateId > 0xa) {\n    return null;\n  }\n\n  switch (actionStateId) {\n    case 0:\n      return \"down\";\n    case 1:\n      return \"left\";\n    case 2:\n      return \"right\";\n    default:\n      return \"up\";\n  }\n}\n","import { format } from \"date-fns\";\n\nimport type { GameStartType } from \"../types\";\nimport { TimerType } from \"../types\";\nimport { exists } from \"./exists\";\n\nexport function frameToGameTimer(\n  frame: number,\n  options: Pick<GameStartType, \"timerType\" | \"startingTimerSeconds\">,\n): string {\n  const { timerType, startingTimerSeconds } = options;\n\n  if (timerType === TimerType.DECREASING) {\n    if (!exists(startingTimerSeconds)) {\n      return \"Unknown\";\n    }\n    const centiseconds = Math.ceil((((60 - (frame % 60)) % 60) * 99) / 59);\n    const date = new Date(0, 0, 0, 0, 0, startingTimerSeconds - frame / 60, centiseconds * 10);\n    return format(date, \"mm:ss.SS\");\n  }\n\n  if (timerType === TimerType.INCREASING) {\n    const centiseconds = Math.floor(((frame % 60) * 99) / 59);\n    const date = new Date(0, 0, 0, 0, 0, frame / 60, centiseconds * 10);\n    return format(date, \"mm:ss.SS\");\n  }\n\n  return \"Infinite\";\n}\n"],"names":["DEFAULT_COLOR","UnknownCharacter","id","name","shortName","colors","generateCharacterInfo","info","_info$shortName","_info$colors","getCharacterInfo","externalCharacterId","data","characters","toString","Object","entries","map","parseInt","sort","a","b","characterColor","UnknownMove","getMoveInfo","moveId","moveName","moveNames","UnknownStage","getStageInfo","stageId","stageName","stageNames","Character","Stage","State","Timers","PUNISH_RESET_FRAMES","RECOVERY_RESET_FRAMES","COMBO_STRING_RESET_FRAMES","getSinglesPlayerPermutationsFromSettings","settings","players","length","playerIndex","opponentIndex","didLoseStock","frame","prevFrame","stocksRemaining","isInControl","state","ground","GROUNDED_CONTROL_START","GROUNDED_CONTROL_END","squat","SQUAT_START","SQUAT_END","groundAttack","GROUND_ATTACK_START","GROUND_ATTACK_END","isGrab","GRAB","isTeching","TECH_START","TECH_END","isDown","DOWN_START","DOWN_END","isDamaged","DAMAGE_START","DAMAGE_END","DAMAGE_FALL","JAB_RESET_UP","JAB_RESET_DOWN","isGrabbed","CAPTURE_START","CAPTURE_END","isCommandGrabbed","COMMAND_GRAB_RANGE1_START","COMMAND_GRAB_RANGE1_END","COMMAND_GRAB_RANGE2_START","COMMAND_GRAB_RANGE2_END","BARREL_WAIT","isDead","DYING_START","DYING_END","calcDamageTaken","_frame$percent","_prevFrame$percent","percent","dashDanceAnimations","DASH","TURN","ActionsComputer","constructor","this","playerPermutations","Array","Map","setup","forEach","indices","set","playerCounts","wavedashCount","wavelandCount","airDodgeCount","dashDanceCount","spotDodgeCount","ledgegrabCount","rollCount","lCancelCount","success","fail","attackCount","jab1","jab2","jab3","jabm","dash","ftilt","utilt","dtilt","fsmash","usmash","dsmash","nair","fair","bair","uair","dair","grabCount","throwCount","up","forward","back","down","groundTechCount","away","in","neutral","wallTechCount","animations","actionFrameCounters","processFrame","get","playerFrame","post","opponentFrame","incrementCount","field","condition","current","currentAnimation","actionStateId","push","currentFrameCounter","actionStateCounter","last3Frames","slice","prevAnimation","animation","isEqual","ROLL_BACKWARD","ROLL_FORWARD","SPOT_DODGE","AIR_DODGE","CLIFF_CATCH","isGrabbing","isGrabAction","DASH_GRAB","ATTACK_DASH","ATTACK_JAB1","ATTACK_JAB2","ATTACK_JAB3","ATTACK_JABM","ATTACK_FTILT_START","ATTACK_FTILT_END","isForwardTilt","ATTACK_UTILT","ATTACK_DTILT","ATTACK_FSMASH_START","ATTACK_FSMASH_END","isForwardSmash","ATTACK_USMASH","ATTACK_DSMASH","AERIAL_NAIR","AERIAL_FAIR","AERIAL_BAIR","AERIAL_UAIR","AERIAL_DAIR","internalCharacterId","GNW_JAB1","GNW_JABM","GNW_DTILT","GNW_FSMASH","GNW_NAIR","GNW_BAIR","GNW_UAIR","PEACH_FSMASH1","PEACH_FSMASH2","PEACH_FSMASH3","THROW_UP","THROW_FORWARD","THROW_DOWN","THROW_BACK","facingOpponent","facingDirection","positionX","TECH_MISS_DOWN","TECH_MISS_UP","isMissGroundTech","FORWARD_TECH","BACKWARD_TECH","NEUTRAL_TECH","WALL_TECH","MISSED_WALL_TECH","AERIAL_ATTACK_START","AERIAL_ATTACK_END","isAerialAttack","lCancelStatus","counts","isSpecialLanding","last","LANDING_FALL_SPECIAL","isAcceptablePrevious","isAboveMin","CONTROLLED_JUMP_START","isBelowMax","CONTROLLED_JUMP_END","isWavedashInitiationAnimation","recentFrames","recentAnimations","keyBy","size","ACTION_KNEE_BEND","handleActionWavedash","handleActionCompute","fetch","from","values","val","ComboEvent","Command","GameMode","Language","TimerType","ItemSpawnType","EnabledItemType","GameEndMethod","Frames","JoystickRegion","ComboComputer","EventEmitter","args","super","combos","combo","move","resetCounter","lastHitAnimation","event","allFrames","frames","currentFrameNumber","prevFrameNumber","prevPlayerFrame","prevOpponentFrame","oppActionStateId","opntIsDamaged","opntIsGrabbed","opntIsCommandGrabbed","opntDamageTaken","comboStarted","_prevOpponentFrame$pe","_opponentFrame$percen","startFrame","endFrame","startPercent","currentPercent","endPercent","moves","didKill","lastHitBy","lastAttackLanded","hitCount","damage","COMBO_EXTEND","COMBO_START","opntIsTeching","opntIsDowned","opntDidLoseStock","opntIsDying","_opponentFrame$percen2","shouldTerminate","_prevOpponentFrame$pe2","COMBO_END","handleComboCompute","emit","ConversionComputer","conversions","metadata","lastEndFrameByOppIdx","conversion","terminated","openingType","opntInControl","handleConversionCompute","_populateConversionTypes","conversionsToHandle","filter","groupedConversions","groupBy","orderBy","isTrade","lastMove","oppEndFrame","InputComputer","inputCount","joystickInputCount","cstickInputCount","buttonInputCount","triggerInputCount","pre","FIRST_PLAYABLE","newInputsPressed","x","count","bits","countSetBits","physicalButtons","prevAnalogRegion","getJoystickRegion","joystickX","joystickY","currentAnalogRegion","DZ","prevCstickRegion","cStickX","cStickY","currentCstickRegion","physicalLTrigger","physicalRTrigger","handleInputCompute","y","region","NE","SE","SW","NW","N","E","S","W","generateOverallStats","inputs","playableFrameCount","inputsByPlayer","originalConversions","conversionsByPlayer","conv","_conv$moves$","conversionsByPlayerByOpening","mapValues","gameMinutes","player","playerInputs","inputCounts","buttons","triggers","cstick","joystick","total","conversionCount","successfulConversionCount","opponentIndices","opp","isTeams","teamId","totalDamage","killCount","successfulConversions","getRatio","inputsPerMinute","digitalInputsPerMinute","openingsPerKill","damagePerOpening","neutralWinRatio","getOpeningRatio","counterHitRatio","beneficialTradeRatio","getBeneficialTradeRatio","ratio","type","openings","opponentOpenings","flatten","playerTrades","opponentTrades","benefitsPlayer","zip","conversionPair","playerConversion","first","opponentConversion","defaultOptions","processOnTheFly","Stats","options","lastProcessedFrame","allComputers","assign","v","comp","register","computer","process","i","FIRST","isCompletedFrame","addFrame","StockComputer","stocks","stock","_prevPlayerFrame$perc","deathAnimation","_playerFrame$percent","handleStockCompute","exists","value","TargetBreakComputer","targetBreaks","isTargetTestGame","gameMode","TARGET_TEST","_frames$currentFrameN","_frames$currentFrameN2","_frames$prevFrameNumb","_frames$prevFrameNumb2","_frames$Frames$FIRST$","_frames$Frames$FIRST","items","item","typeId","target","spawnId","frameDestroyed","positionY","currentTargets","previousTargets","currentTargetIds","includes","targetBreak","find","handleTargetBreak","CommunicationType","ConnectionEvent","ConnectionStatus","Ports","ConsoleCommunication","receiveBuf","Buffer","messages","receive","concat","msgSize","readUInt32BE","ubjsonData","decode","getReceiveBuffer","getMessages","toReturn","genHandshakeOut","cursor","clientToken","isRealtime","clientTokenBuf","writeUInt32BE","message","HANDSHAKE","payload","Uint8Array","buf","encode","optimizeArrays","msg","byteLength","NETWORK_MESSAGE","CommunicationState","defaultConnectionDetails","consoleNick","gameDataCursor","version","consoleConnectionOptions","autoReconnect","DolphinMessageType","SlpInputSource","SlpStreamMode","toHalfwidth","str","ret","char","convertChar","charCode","charCodeAt","String","fromCharCode","readRef","ref","buffer","offset","position","source","FILE","console","error","Error","BUFFER","copy","getLenRef","openSlpFile","input","getRef","rawDataPosition","getRawDataPosition","rawDataLength","fileSize","rawDataLen","getRawDataLength","metadataPosition","metadataLength","getMetadataLength","messageSizes","MESSAGE_SIZES","payloadLength","messageSizesBuffer","getMessageSizes","getEnabledItems","view","reduce","acc","byteOffset","index","readUint8","getGameInfoBlock","gameBitfield1","gameBitfield2","gameBitfield3","gameBitfield4","bombRainEnabled","selfDestructScoreValue","readInt8","itemSpawnBitfield1","itemSpawnBitfield2","itemSpawnBitfield3","itemSpawnBitfield4","itemSpawnBitfield5","damageRatio","readFloat","iterateEvents","slpFile","callback","startPos","readPosition","stopReadingAt","commandPayloadBuffers","splitMessageBuffer","commandByteBuffer","_commandByteBuffer$","commandByte","undefined","advanceAmount","SPLIT_MESSAGE","_readUint","_readUint2","DataView","readUint16","isLastMessage","readBool","internalCommand","appendBuf","mergedBuf","_splitMessageBuffer$","parseMessage","command","GAME_START","getPlayerObject","cfOffset","dashback","readUint32","controllerFix","nametagStart","nametagBuf","nameTagString","iconv","split","shift","nametag","displayNameStart","displayNameBuf","displayNameString","displayName","connectCodeStart","connectCodeBuf","connectCodeString","connectCode","userIdStart","userIdBuf","userIdString","userId","port","characterId","startStocks","teamShade","handicap","staminaMode","Boolean","silentCharacter","lowGravity","invisible","blackStockIcon","metal","startOnAngelPlatform","rumbleEnabled","cpuLevel","offenseRatio","defenseRatio","modelScale","matchIdStart","matchIdBuf","matchIdString","matchId","slpVersion","timerType","inGameMode","friendlyFireEnabled","itemSpawnBehavior","startingTimerSeconds","enabledItems","scene","language","gameInfoBlock","randomSeed","isPAL","isFrozenPS","matchInfo","gameNumber","tiebreakerNumber","FRAME_START","readInt32","seed","sceneFrameCounter","PRE_FRAME_UPDATE","isFollower","trigger","rawJoystickX","POST_FRAME_UPDATE","selfInducedSpeeds","airX","attackX","attackY","groundX","shieldSize","currentComboCount","miscActionState","isAirborne","lastGroundId","jumpsRemaining","hurtboxCollisionState","hitlagRemaining","animationIndex","instanceHitBy","instanceId","ITEM_UPDATE","velocityX","velocityY","damageTaken","expirationTimer","missileType","turnipFace","chargeShotLaunched","chargePower","owner","FRAME_BOOKEND","latestFinalizedFrame","GAME_END","placements","gameEndMethod","lrasInitiatorIndex","GECKO_LIST","codes","pos","_readUint3","word1","codetype","address","_readUint4","_readUint5","contents","canReadFromView","getFloat32","getInt32","getInt8","getUint32","getUint16","bitmask","getUint8","getMetadata","ex","getGameEnd","gameEndPayloadSize","gameEndSize","gameEndPosition","extractFinalPostFrameUpdates","postFramePayloadSize","frameBookendPayloadSize","postFrameSize","frameNum","postFramePosition","postFrameUpdates","postFrameMessage","unshift","defaultSettings","suppressErrors","mode","AUTO","SlpStreamEvent","SlpStream","Writable","slpOptions","opts","gameEnded","payloadSizes","previousBuffer","restart","_write","newData","encoding","dataView","payloadSize","_this$payloadSizes$ge","MANUAL","payloadPtr","payloadDataView","payloadLen","_processCommand","err","_writeCommand","entirePayload","payloadBuf","bufToWrite","RAW","processReceiveCommands","COMMAND","_this$payloadSizes$ge2","parsedPayload","DEFAULT_NICKNAME","SlpFile","filePath","slpStream","fileStream","usesExternalStream","consoleNickname","startTime","Date","lastFrame","_setupListeners","_initializeNewGame","path","setMetadata","chunk","write","_onCommand","characterUsage","names","netplay","code","prevPlayer","curCharFrames","streamListener","on","removeListener","end","_final","footer","startTimeStr","toISOString","createInt32Buffer","usage","internalId","createUInt32Buffer","number","alloc","writeInt32BE","outputFiles","folderPath","newFilename","folder","date","join","format","SlpFileWriterEvent","SlpParserEvent","RollbackCounter","rollbackFrames","rollbackFrameCount","rollbackPlayerIdx","lastFrameWasRollback","currentRollbackLength","rollbackLengths","checkIfRollbackFrame","currentFrame","playerIdx","getFrames","getCount","getLengths","defaultSlpParserOptions","strict","SlpParser","rollbackCounter","gameEnd","latestFrameIndex","settingsComplete","lastFinalizedFrame","geckoList","handleCommand","_handleGameStart","_handleFrameStart","_handlePostFrameUpdate","_handleFrameUpdate","_handleItemUpdate","_handleFrameBookend","_handleGameEnd","_handleGeckoList","reset","getLatestFrameNumber","_this$latestFrameInde","getPlayableFrameCount","getLatestFrame","frameIndex","getSettings","getItems","_this$settings","_this$settings2","OFF","itemBitfield","Math","floor","getRollbackFrames","lengths","getFrame","num","getGeckoList","_finalizeFrames","END","semver","gte","_completeSettings","playersByIndex","location","ROLLBACK_FRAME","lte","FRAME","_this$frames$currentF","_this$frames$currentF2","ONLINE","frameToFinalize","playerFrameInfo","FINALIZED_FRAME","SETTINGS","ipAddress","connectionStatus","DISCONNECTED","connDetails","client","connection","shouldReconnect","DEFAULT","getStatus","getDetails","connect","ip","timeout","_connectOnPort","reconnect","inject","_setStatus","CONNECTING","consoleComms","initialDelay","maxDelay","strategy","failAfter","Infinity","_this$connDetails$cli","CONNECT","setConnectingStatus","RECONNECT_WAIT","disconnect","warn","ERROR","destroy","_getInitialCommState","LEGACY","openingBytes","equals","NORMAL","_processMessage","MESSAGE","KEEP_ALIVE","fakeKeepAlive","_handleReplayData","REPLAY","readPos","cmp","compare","forcePos","nextPos","nick","nintendontVersion","tokenBuf","DATA","status","STATUS_CHANGE","gameCursor","nickname","peer","log","enet","Promise","resolve","then","_interopNamespace","require","createClient","peers","channels","newPeer","ping","CONNECTED","packet","Packet","JSON","stringify","PACKET_FLAG","RELIABLE","send","dataString","parse","dolphin_closed","CONNECT_REPLY","GAME_EVENT","_updateCursor","gameData","START_GAME","END_GAME","next_cursor","finalStats","parser","actionsComputer","conversionComputer","comboComputer","stockComputer","inputComputer","targetBreakComputer","statsComputer","ArrayBuffer","_process","shouldStop","file","slpfile","skipProcessing","getStats","overall","gameComplete","stats","actionCounts","getStadiumStats","latestFrame","HOME_RUN_CONTEST","distanceInfo","_sandbagLastFrame$pos","sandbagLastFrame","units","JAPANESE","distance","score","fround","round","max","positionToHomeRunDistance","extractDistanceInfoFromFrame","getFilePath","_this$input$filePath","getWinners","finalPostFrameUpdates","TIME","_players$find$teamId","_players$find2","NO_CONTEST","UNRESOLVED","_players$find","winnerIndex","nonFollowerUpdates","pfu","p1","p2","p1Health","trunc","p2Health","firstPosition","placement","winningTeam","_players$find$teamId2","_players$find3","currentFile","_writePayload","_handleNewGame","_handleEndGame","getCurrentFilename","endCurrentFile","updateSettings","NEW_FILE","FILE_COMPLETE","DECREASING","centiseconds","ceil","INCREASING"],"mappings":"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"}