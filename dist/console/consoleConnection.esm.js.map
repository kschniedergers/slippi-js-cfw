{"version":3,"file":"consoleConnection.esm.js","sources":["../../src/console/consoleConnection.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport inject from \"reconnect-core\";\n\nimport type { CommunicationMessage } from \"./communication\";\nimport { CommunicationType, ConsoleCommunication } from \"./communication\";\nimport type { Connection, ConnectionDetails, ConnectionSettings } from \"./types\";\nimport { ConnectionEvent, ConnectionStatus, Ports } from \"./types\";\n\nexport const NETWORK_MESSAGE = \"HELO\\0\";\n\nconst DEFAULT_CONNECTION_TIMEOUT_MS = 20000;\n\nenum CommunicationState {\n  INITIAL = \"initial\",\n  LEGACY = \"legacy\",\n  NORMAL = \"normal\",\n}\n\nconst defaultConnectionDetails: ConnectionDetails = {\n  consoleNick: \"unknown\",\n  gameDataCursor: Uint8Array.from([0, 0, 0, 0, 0, 0, 0, 0]),\n  version: \"\",\n  clientToken: 0,\n};\n\nconst consoleConnectionOptions = {\n  autoReconnect: true,\n};\n\nexport type ConsoleConnectionOptions = typeof consoleConnectionOptions;\n\n/**\n * Responsible for maintaining connection to a Slippi relay connection or Wii connection.\n * Events are emitted whenever data is received.\n *\n * Basic usage example:\n *\n * ```javascript\n * const { ConsoleConnection } = require(\"@slippi/slippi-js\");\n *\n * const connection = new ConsoleConnection();\n * connection.connect(\"localhost\", 667); // You should set these values appropriately\n *\n * connection.on(\"data\", (data) => {\n *   // Received data from console\n *   console.log(data);\n * });\n *\n * connection.on(\"statusChange\", (status) => {\n *   console.log(`status changed: ${status}`);\n * });\n * ```\n */\nexport class ConsoleConnection extends EventEmitter implements Connection {\n  private ipAddress: string;\n  private port: number;\n  private isRealtime: boolean;\n  private connectionStatus = ConnectionStatus.DISCONNECTED;\n  private connDetails: ConnectionDetails = { ...defaultConnectionDetails };\n  private client: any | null = null;\n  private connection: inject.Instance<unknown, any> | null = null;\n  private options: ConsoleConnectionOptions;\n  private shouldReconnect = false;\n\n  public constructor(options?: Partial<ConsoleConnectionOptions>) {\n    super();\n    this.ipAddress = \"0.0.0.0\";\n    this.port = Ports.DEFAULT;\n    this.isRealtime = false;\n    this.options = Object.assign({}, consoleConnectionOptions, options);\n  }\n\n  /**\n   * @returns The current connection status.\n   */\n  public getStatus(): ConnectionStatus {\n    return this.connectionStatus;\n  }\n\n  /**\n   * @returns The IP address and port of the current connection.\n   */\n  public getSettings(): ConnectionSettings {\n    return {\n      ipAddress: this.ipAddress,\n      port: this.port,\n    };\n  }\n\n  /**\n   * @returns The specific details about the connected console.\n   */\n  public getDetails(): ConnectionDetails {\n    return { ...this.connDetails };\n  }\n\n  /**\n   * Initiate a connection to the Wii or Slippi relay.\n   * @param ip   The IP address of the Wii or Slippi relay.\n   * @param port The port to connect to.\n   * @param isRealtime Optional. A flag to tell the Wii to send data as quickly as possible\n   * @param timeout Optional. The timeout in milliseconds when attempting to connect\n   *                to the Wii or relay.\n   */\n  public connect(ip: string, port: number, isRealtime = false, timeout = DEFAULT_CONNECTION_TIMEOUT_MS): void {\n    this.ipAddress = ip;\n    this.port = port;\n    this.isRealtime = isRealtime;\n    this._connectOnPort(ip, port, timeout);\n  }\n\n  private _connectOnPort(ip: string, port: number, timeout: number): void {\n    // set up reconnect\n    const reconnect = inject(\n      () => {},\n      // net.connect({\n      //   host: ip,\n      //   port: port,\n      //   timeout: timeout,\n      // }),\n    );\n\n    // Indicate we are connecting\n    this._setStatus(ConnectionStatus.CONNECTING);\n\n    // Prepare console communication obj for talking UBJSON\n    const consoleComms = new ConsoleCommunication();\n\n    // TODO: reconnect on failed reconnect, not sure how\n    // TODO: to do this\n    const connection = reconnect(\n      {\n        initialDelay: 2000,\n        maxDelay: 10000,\n        strategy: \"fibonacci\",\n        failAfter: Infinity,\n      },\n      (client) => {\n        this.emit(ConnectionEvent.CONNECT);\n        // We successfully connected so turn on auto-reconnect\n        this.shouldReconnect = this.options.autoReconnect;\n        this.client = client;\n\n        let commState: CommunicationState = CommunicationState.INITIAL;\n        // client.on(\"data\", (data) => {\n        //   if (commState === CommunicationState.INITIAL) {\n        //     commState = this._getInitialCommState(data);\n        //     console.log(`Connected to ${ip}:${port} with type: ${commState}`);\n        //     this._setStatus(ConnectionStatus.CONNECTED);\n        //     console.log(data.toString(\"hex\"));\n        //   }\n\n        //   if (commState === CommunicationState.LEGACY) {\n        //     // If the first message received was not a handshake message, either we\n        //     // connected to an old Nintendont version or a relay instance\n        //     this._handleReplayData(data);\n        //     return;\n        //   }\n\n        //   try {\n        //     consoleComms.receive(data);\n        //   } catch (err) {\n        //     console.error(\"Failed to process new data from server...\", {\n        //       error: err,\n        //       prevDataBuf: consoleComms.getReceiveBuffer(),\n        //       rcvData: data,\n        //     });\n        //     client.destroy();\n        //     this.emit(ConnectionEvent.ERROR, err);\n        //     return;\n        //   }\n        //   const messages = consoleComms.getMessages();\n\n        //   // Process all of the received messages\n        //   try {\n        //     messages.forEach((message) => this._processMessage(message));\n        //   } catch (err) {\n        //     // Disconnect client to send another handshake message\n        //     console.error(err);\n        //     client.destroy();\n        //     this.emit(ConnectionEvent.ERROR, err);\n        //   }\n        // });\n\n        // client.on(\"timeout\", () => {\n        //   // const previouslyConnected = this.connectionStatus === ConnectionStatus.CONNECTED;\n        //   console.warn(`Attempted connection to ${ip}:${port} timed out after ${timeout}ms`);\n        //   client.destroy();\n        // });\n\n        // client.on(\"end\", () => {\n        //   console.log(\"disconnect\");\n        //   if (!this.shouldReconnect) {\n        //     client.destroy();\n        //   }\n        // });\n\n        // client.on(\"close\", () => {\n        //   console.log(\"connection was closed\");\n        // });\n\n        const handshakeMsgOut = consoleComms.genHandshakeOut(\n          this.connDetails.gameDataCursor as Uint8Array,\n          this.connDetails.clientToken ?? 0,\n          this.isRealtime,\n        );\n\n        // client.write(handshakeMsgOut);\n      },\n    );\n\n    const setConnectingStatus = (): void => {\n      // Indicate we are connecting\n      this._setStatus(this.shouldReconnect ? ConnectionStatus.RECONNECT_WAIT : ConnectionStatus.CONNECTING);\n    };\n\n    connection.on(\"connect\", setConnectingStatus);\n    connection.on(\"reconnect\", setConnectingStatus);\n\n    connection.on(\"disconnect\", () => {\n      if (!this.shouldReconnect) {\n        connection.reconnect = false;\n        connection.disconnect();\n        this._setStatus(ConnectionStatus.DISCONNECTED);\n      }\n      // TODO: Figure out how to set RECONNECT_WAIT state here. Currently it will stay on\n      // TODO: Connecting... forever\n    });\n\n    connection.on(\"error\", (err) => {\n      console.warn(`Connection on port ${port} encountered an error.`, err);\n\n      this._setStatus(ConnectionStatus.DISCONNECTED);\n      this.emit(ConnectionEvent.ERROR, `Connection on port ${port} encountered an error.\\n${err}`);\n    });\n\n    this.connection = connection;\n    connection.connect(port);\n  }\n\n  /**\n   * Terminate the current connection.\n   */\n  public disconnect(): void {\n    // Prevent reconnections and disconnect\n    if (this.connection) {\n      this.connection.reconnect = false;\n      this.connection.disconnect();\n      this.connection = null;\n    }\n\n    if (this.client) {\n      this.client.destroy();\n    }\n  }\n\n  private _getInitialCommState(data: Buffer): CommunicationState {\n    if (data.length < 13) {\n      return CommunicationState.LEGACY;\n    }\n\n    const openingBytes = Buffer.from([0x7b, 0x69, 0x04, 0x74, 0x79, 0x70, 0x65, 0x55, 0x01]);\n\n    const dataStart = data.slice(4, 13);\n\n    return dataStart.equals(openingBytes) ? CommunicationState.NORMAL : CommunicationState.LEGACY;\n  }\n\n  private _processMessage(message: CommunicationMessage): void {\n    this.emit(ConnectionEvent.MESSAGE, message);\n    switch (message.type) {\n      case CommunicationType.KEEP_ALIVE:\n        // console.log(\"Keep alive message received\");\n\n        // TODO: This is the jankiest shit ever but it will allow for relay connections not\n        // TODO: to time out as long as the main connection is still receving keep alive messages\n        // TODO: Need to figure out a better solution for this. There should be no need to have an\n        // TODO: active Wii connection for the relay connection to keep itself alive\n        const fakeKeepAlive = Buffer.from(NETWORK_MESSAGE);\n        this._handleReplayData(fakeKeepAlive);\n\n        break;\n      case CommunicationType.REPLAY:\n        const readPos = Uint8Array.from(message.payload.pos);\n        const cmp = Buffer.compare(this.connDetails.gameDataCursor as Uint8Array, readPos);\n        if (!message.payload.forcePos && cmp !== 0) {\n          // The readPos is not the one we are waiting on, throw error\n          throw new Error(\n            `Position of received data is incorrect. Expected: ${this.connDetails.gameDataCursor.toString()}, Received: ${readPos.toString()}`,\n          );\n        }\n\n        if (message.payload.forcePos) {\n          console.warn(\n            \"Overflow occured in Nintendont, data has likely been skipped and replay corrupted. \" +\n              \"Expected, Received:\",\n            this.connDetails.gameDataCursor,\n            readPos,\n          );\n        }\n\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.nextPos);\n\n        const data = Uint8Array.from(message.payload.data);\n        this._handleReplayData(data);\n        break;\n      case CommunicationType.HANDSHAKE:\n        const { nick, nintendontVersion } = message.payload;\n        if (nick) {\n          this.connDetails.consoleNick = nick;\n        }\n        const tokenBuf = Buffer.from(message.payload.clientToken);\n        this.connDetails.clientToken = tokenBuf.readUInt32BE(0);\n        if (nintendontVersion) {\n          this.connDetails.version = nintendontVersion;\n        }\n        this.connDetails.gameDataCursor = Uint8Array.from(message.payload.pos);\n        this.emit(ConnectionEvent.HANDSHAKE, this.connDetails);\n        break;\n      default:\n        // Should this be an error?\n        break;\n    }\n  }\n\n  private _handleReplayData(data: Uint8Array): void {\n    this.emit(ConnectionEvent.DATA, data);\n  }\n\n  private _setStatus(status: ConnectionStatus): void {\n    // Don't fire the event if the status hasn't actually changed\n    if (this.connectionStatus !== status) {\n      this.connectionStatus = status;\n      this.emit(ConnectionEvent.STATUS_CHANGE, this.connectionStatus);\n    }\n  }\n}\n"],"names":["NETWORK_MESSAGE","DEFAULT_CONNECTION_TIMEOUT_MS","CommunicationState","defaultConnectionDetails","consoleNick","gameDataCursor","Uint8Array","from","version","clientToken","consoleConnectionOptions","autoReconnect","ConsoleConnection","EventEmitter","constructor","options","ipAddress","port","isRealtime","connectionStatus","ConnectionStatus","DISCONNECTED","connDetails","client","connection","shouldReconnect","Ports","DEFAULT","Object","assign","getStatus","getSettings","getDetails","connect","ip","timeout","_connectOnPort","reconnect","inject","_setStatus","CONNECTING","consoleComms","ConsoleCommunication","initialDelay","maxDelay","strategy","failAfter","Infinity","_this$connDetails$cli","emit","ConnectionEvent","CONNECT","genHandshakeOut","setConnectingStatus","RECONNECT_WAIT","on","disconnect","err","console","warn","ERROR","destroy","_getInitialCommState","data","length","LEGACY","openingBytes","Buffer","dataStart","slice","equals","NORMAL","_processMessage","message","MESSAGE","type","CommunicationType","KEEP_ALIVE","fakeKeepAlive","_handleReplayData","REPLAY","readPos","payload","pos","cmp","compare","forcePos","Error","toString","nextPos","HANDSHAKE","nick","nintendontVersion","tokenBuf","readUInt32BE","DATA","status","STATUS_CHANGE"],"mappings":"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"}