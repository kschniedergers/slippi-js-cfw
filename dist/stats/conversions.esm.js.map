{"version":3,"file":"conversions.esm.js","sources":["../../src/stats/conversions.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport filter from \"lodash/filter\";\nimport get from \"lodash/get\";\nimport groupBy from \"lodash/groupBy\";\nimport last from \"lodash/last\";\nimport orderBy from \"lodash/orderBy\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ConversionType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isGrabbed,\n  isInControl,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\ntype PlayerConversionState = {\n  conversion: ConversionType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n};\n\ntype MetadataType = {\n  lastEndFrameByOppIdx: {\n    [oppIdx: number]: number;\n  };\n};\n\nexport class ConversionComputer extends EventEmitter implements StatComputer<ConversionType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private conversions = new Array<ConversionType>();\n  private state = new Map<PlayerIndexedType, PlayerConversionState>();\n  private metadata: MetadataType;\n  private settings: GameStartType | null = null;\n\n  public constructor() {\n    super();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n  }\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n    this.conversions = [];\n    this.state = new Map();\n    this.metadata = {\n      lastEndFrameByOppIdx: {},\n    };\n    this.settings = settings;\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: PlayerConversionState = {\n        conversion: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        const terminated = handleConversionCompute(allFrames, state, indices, frame, this.conversions);\n        if (terminated) {\n          this.emit(\"CONVERSION\", {\n            combo: last(this.conversions),\n            settings: this.settings,\n          });\n        }\n      }\n    });\n  }\n\n  public fetch(): ConversionType[] {\n    this._populateConversionTypes();\n    return this.conversions;\n  }\n\n  private _populateConversionTypes(): void {\n    // Post-processing step: set the openingTypes\n    const conversionsToHandle = filter(this.conversions, (conversion) => {\n      return conversion.openingType === \"unknown\";\n    });\n\n    // Group new conversions by startTime and sort\n    const groupedConversions = groupBy(conversionsToHandle, \"startFrame\");\n    const sortedConversions = orderBy(groupedConversions, (conversions) => get(conversions, [0, \"startFrame\"]));\n\n    // Set the opening types on the conversions we need to handle\n    sortedConversions.forEach((conversions) => {\n      const isTrade = conversions.length >= 2;\n      conversions.forEach((conversion) => {\n        // Set end frame for this conversion\n        this.metadata.lastEndFrameByOppIdx[conversion.playerIndex] = conversion.endFrame!;\n\n        if (isTrade) {\n          // If trade, just short-circuit\n          conversion.openingType = \"trade\";\n          return;\n        }\n\n        // If not trade, check the opponent endFrame\n        const lastMove = last(conversion.moves);\n        const oppEndFrame =\n          this.metadata.lastEndFrameByOppIdx[lastMove ? lastMove.playerIndex : conversion.playerIndex];\n        const isCounterAttack = oppEndFrame && oppEndFrame > conversion.startFrame;\n        conversion.openingType = isCounterAttack ? \"counter-attack\" : \"neutral-win\";\n      });\n    });\n  }\n}\n\nfunction handleConversionCompute(\n  frames: FramesType,\n  state: PlayerConversionState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  conversions: ConversionType[],\n): boolean {\n  const currentFrameNumber = frame.frame;\n  const playerFrame: PostFrameUpdateType = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a conversion or\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    if (!state.conversion) {\n      state.conversion = {\n        playerIndex: indices.opponentIndex,\n        lastHitBy: indices.playerIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        openingType: \"unknown\", // Will be updated later\n      };\n\n      conversions.push(state.conversion);\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.conversion.moves.push(state.move);\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n  }\n\n  if (!state.conversion) {\n    // The rest of the function handles conversion termination logic, so if we don't\n    // have a conversion started, there is no need to continue\n    return false;\n  }\n\n  const opntInControl = isInControl(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.conversion.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  }\n\n  const shouldStartResetCounter = state.resetCounter === 0 && opntInControl;\n  const shouldContinueResetCounter = state.resetCounter > 0;\n  if (shouldStartResetCounter || shouldContinueResetCounter) {\n    // This will increment the reset timer under the following conditions:\n    // 1) if we were punishing opponent but they have now entered an actionable state\n    // 2) if counter has already started counting meaning opponent has entered actionable state\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.conversion.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - conversion resets on time\n  if (state.resetCounter > Timers.PUNISH_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If conversion should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.conversion.endFrame = playerFrame.frame;\n    state.conversion.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n\n    state.conversion = null;\n    state.move = null;\n  }\n\n  return shouldTerminate;\n}\n"],"names":["ConversionComputer","EventEmitter","constructor","playerPermutations","Array","conversions","state","Map","metadata","settings","lastEndFrameByOppIdx","setup","getSinglesPlayerPermutationsFromSettings","forEach","indices","playerState","conversion","move","resetCounter","lastHitAnimation","set","processFrame","frame","allFrames","get","terminated","handleConversionCompute","emit","combo","last","fetch","_populateConversionTypes","conversionsToHandle","filter","openingType","groupedConversions","groupBy","sortedConversions","orderBy","isTrade","length","playerIndex","endFrame","lastMove","moves","oppEndFrame","isCounterAttack","startFrame","frames","currentFrameNumber","playerFrame","players","post","opponentFrame","opponentIndex","prevFrameNumber","prevPlayerFrame","prevOpponentFrame","oppActionStateId","actionStateId","opntIsDamaged","isDamaged","opntIsGrabbed","isGrabbed","opntIsCommandGrabbed","isCommandGrabbed","opntDamageTaken","calcDamageTaken","actionChangedSinceHit","actionCounter","actionStateCounter","prevActionCounter","actionFrameCounterReset","_prevOpponentFrame$pe","_opponentFrame$percen","lastHitBy","startPercent","percent","currentPercent","endPercent","didKill","push","moveId","lastAttackLanded","hitCount","damage","opntInControl","isInControl","opntDidLoseStock","didLoseStock","_opponentFrame$percen2","shouldStartResetCounter","shouldContinueResetCounter","shouldTerminate","Timers","PUNISH_RESET_FRAMES","_prevOpponentFrame$pe2"],"mappings":";;;;;;;;AAkCM,MAAOA,kBAAmB,SAAQC,YAAY,CAAA;AAOlDC,EAAAA,WAAAA,GAAA;AACE,IAAA,KAAK,EAAE,CAAA;AAAC,IAAA,IAAA,CAPFC,kBAAkB,GAAG,IAAIC,KAAK,EAAqB,CAAA;AAAA,IAAA,IAAA,CACnDC,WAAW,GAAG,IAAID,KAAK,EAAkB,CAAA;AAAA,IAAA,IAAA,CACzCE,KAAK,GAAG,IAAIC,GAAG,EAA4C,CAAA;AAAA,IAAA,IAAA,CAC3DC,QAAQ,GAAA,KAAA,CAAA,CAAA;IAAA,IACRC,CAAAA,QAAQ,GAAyB,IAAI,CAAA;IAI3C,IAAI,CAACD,QAAQ,GAAG;AACdE,MAAAA,oBAAoB,EAAE,EAAE;KACzB,CAAA;AACH,GAAA;EAEOC,KAAKA,CAACF,QAAuB,EAAA;AAClC;AACA,IAAA,IAAI,CAACN,kBAAkB,GAAGS,wCAAwC,CAACH,QAAQ,CAAC,CAAA;IAC5E,IAAI,CAACJ,WAAW,GAAG,EAAE,CAAA;AACrB,IAAA,IAAI,CAACC,KAAK,GAAG,IAAIC,GAAG,EAAE,CAAA;IACtB,IAAI,CAACC,QAAQ,GAAG;AACdE,MAAAA,oBAAoB,EAAE,EAAE;KACzB,CAAA;IACD,IAAI,CAACD,QAAQ,GAAGA,QAAQ,CAAA;AAExB,IAAA,IAAI,CAACN,kBAAkB,CAACU,OAAO,CAAEC,OAAO,IAAI;AAC1C,MAAA,MAAMC,WAAW,GAA0B;AACzCC,QAAAA,UAAU,EAAE,IAAI;AAChBC,QAAAA,IAAI,EAAE,IAAI;AACVC,QAAAA,YAAY,EAAE,CAAC;AACfC,QAAAA,gBAAgB,EAAE,IAAA;OACnB,CAAA;MACD,IAAI,CAACb,KAAK,CAACc,GAAG,CAACN,OAAO,EAAEC,WAAW,CAAC,CAAA;AACtC,KAAC,CAAC,CAAA;AACJ,GAAA;AAEOM,EAAAA,YAAYA,CAACC,KAAqB,EAAEC,SAAqB,EAAA;AAC9D,IAAA,IAAI,CAACpB,kBAAkB,CAACU,OAAO,CAAEC,OAAO,IAAI;MAC1C,MAAMR,KAAK,GAAG,IAAI,CAACA,KAAK,CAACkB,GAAG,CAACV,OAAO,CAAC,CAAA;AACrC,MAAA,IAAIR,KAAK,EAAE;AACT,QAAA,MAAMmB,UAAU,GAAGC,uBAAuB,CAACH,SAAS,EAAEjB,KAAK,EAAEQ,OAAO,EAAEQ,KAAK,EAAE,IAAI,CAACjB,WAAW,CAAC,CAAA;AAC9F,QAAA,IAAIoB,UAAU,EAAE;AACd,UAAA,IAAI,CAACE,IAAI,CAAC,YAAY,EAAE;AACtBC,YAAAA,KAAK,EAAEC,IAAI,CAAC,IAAI,CAACxB,WAAW,CAAC;YAC7BI,QAAQ,EAAE,IAAI,CAACA,QAAAA;AAChB,WAAA,CAAC,CAAA;AACH,SAAA;AACF,OAAA;AACH,KAAC,CAAC,CAAA;AACJ,GAAA;AAEOqB,EAAAA,KAAKA,GAAA;IACV,IAAI,CAACC,wBAAwB,EAAE,CAAA;IAC/B,OAAO,IAAI,CAAC1B,WAAW,CAAA;AACzB,GAAA;AAEQ0B,EAAAA,wBAAwBA,GAAA;AAC9B;IACA,MAAMC,mBAAmB,GAAGC,MAAM,CAAC,IAAI,CAAC5B,WAAW,EAAGW,UAAU,IAAI;AAClE,MAAA,OAAOA,UAAU,CAACkB,WAAW,KAAK,SAAS,CAAA;AAC7C,KAAC,CAAC,CAAA;AAEF;AACA,IAAA,MAAMC,kBAAkB,GAAGC,OAAO,CAACJ,mBAAmB,EAAE,YAAY,CAAC,CAAA;AACrE,IAAA,MAAMK,iBAAiB,GAAGC,OAAO,CAACH,kBAAkB,EAAG9B,WAAW,IAAKmB,GAAG,CAACnB,WAAW,EAAE,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC,CAAC,CAAA;AAE3G;AACAgC,IAAAA,iBAAiB,CAACxB,OAAO,CAAER,WAAW,IAAI;AACxC,MAAA,MAAMkC,OAAO,GAAGlC,WAAW,CAACmC,MAAM,IAAI,CAAC,CAAA;AACvCnC,MAAAA,WAAW,CAACQ,OAAO,CAAEG,UAAU,IAAI;AACjC;AACA,QAAA,IAAI,CAACR,QAAQ,CAACE,oBAAoB,CAACM,UAAU,CAACyB,WAAW,CAAC,GAAGzB,UAAU,CAAC0B,QAAS,CAAA;AAEjF,QAAA,IAAIH,OAAO,EAAE;AACX;UACAvB,UAAU,CAACkB,WAAW,GAAG,OAAO,CAAA;AAChC,UAAA,OAAA;AACD,SAAA;AAED;AACA,QAAA,MAAMS,QAAQ,GAAGd,IAAI,CAACb,UAAU,CAAC4B,KAAK,CAAC,CAAA;AACvC,QAAA,MAAMC,WAAW,GACf,IAAI,CAACrC,QAAQ,CAACE,oBAAoB,CAACiC,QAAQ,GAAGA,QAAQ,CAACF,WAAW,GAAGzB,UAAU,CAACyB,WAAW,CAAC,CAAA;QAC9F,MAAMK,eAAe,GAAGD,WAAW,IAAIA,WAAW,GAAG7B,UAAU,CAAC+B,UAAU,CAAA;AAC1E/B,QAAAA,UAAU,CAACkB,WAAW,GAAGY,eAAe,GAAG,gBAAgB,GAAG,aAAa,CAAA;AAC7E,OAAC,CAAC,CAAA;AACJ,KAAC,CAAC,CAAA;AACJ,GAAA;AACD,CAAA;AAED,SAASpB,uBAAuBA,CAC9BsB,MAAkB,EAClB1C,KAA4B,EAC5BQ,OAA0B,EAC1BQ,KAAqB,EACrBjB,WAA6B,EAAA;AAE7B,EAAA,MAAM4C,kBAAkB,GAAG3B,KAAK,CAACA,KAAK,CAAA;EACtC,MAAM4B,WAAW,GAAwB5B,KAAK,CAAC6B,OAAO,CAACrC,OAAO,CAAC2B,WAAW,CAAE,CAACW,IAAI,CAAA;EACjF,MAAMC,aAAa,GAAG/B,KAAK,CAAC6B,OAAO,CAACrC,OAAO,CAACwC,aAAa,CAAE,CAACF,IAAI,CAAA;AAEhE,EAAA,MAAMG,eAAe,GAAGN,kBAAkB,GAAG,CAAC,CAAA;EAC9C,IAAIO,eAAe,GAA+B,IAAI,CAAA;EACtD,IAAIC,iBAAiB,GAA+B,IAAI,CAAA;AAExD,EAAA,IAAIT,MAAM,CAACO,eAAe,CAAC,EAAE;AAC3BC,IAAAA,eAAe,GAAGR,MAAM,CAACO,eAAe,CAAE,CAACJ,OAAO,CAACrC,OAAO,CAAC2B,WAAW,CAAE,CAACW,IAAI,CAAA;AAC7EK,IAAAA,iBAAiB,GAAGT,MAAM,CAACO,eAAe,CAAE,CAACJ,OAAO,CAACrC,OAAO,CAACwC,aAAa,CAAE,CAACF,IAAI,CAAA;AAClF,GAAA;AAED,EAAA,MAAMM,gBAAgB,GAAGL,aAAa,CAACM,aAAc,CAAA;AACrD,EAAA,MAAMC,aAAa,GAAGC,SAAS,CAACH,gBAAgB,CAAC,CAAA;AACjD,EAAA,MAAMI,aAAa,GAAGC,SAAS,CAACL,gBAAgB,CAAC,CAAA;AACjD,EAAA,MAAMM,oBAAoB,GAAGC,gBAAgB,CAACP,gBAAgB,CAAC,CAAA;EAC/D,MAAMQ,eAAe,GAAGT,iBAAiB,GAAGU,eAAe,CAACd,aAAa,EAAEI,iBAAiB,CAAC,GAAG,CAAC,CAAA;AAEjG;AACA;AACA;AACA;AACA;AACA;EACA,MAAMW,qBAAqB,GAAGlB,WAAW,CAACS,aAAa,KAAKrD,KAAK,CAACa,gBAAgB,CAAA;AAClF,EAAA,MAAMkD,aAAa,GAAGnB,WAAW,CAACoB,kBAAmB,CAAA;EACrD,MAAMC,iBAAiB,GAAGf,eAAe,GAAGA,eAAe,CAACc,kBAAmB,GAAG,CAAC,CAAA;AACnF,EAAA,MAAME,uBAAuB,GAAGH,aAAa,GAAGE,iBAAiB,CAAA;EACjE,IAAIH,qBAAqB,IAAII,uBAAuB,EAAE;IACpDlE,KAAK,CAACa,gBAAgB,GAAG,IAAI,CAAA;AAC9B,GAAA;AAED;AACA;AACA,EAAA,IAAIyC,aAAa,IAAIE,aAAa,IAAIE,oBAAoB,EAAE;AAC1D,IAAA,IAAI,CAAC1D,KAAK,CAACU,UAAU,EAAE;MAAA,IAAAyD,qBAAA,EAAAC,qBAAA,CAAA;MACrBpE,KAAK,CAACU,UAAU,GAAG;QACjByB,WAAW,EAAE3B,OAAO,CAACwC,aAAa;QAClCqB,SAAS,EAAE7D,OAAO,CAAC2B,WAAW;AAC9BM,QAAAA,UAAU,EAAEE,kBAAkB;AAC9BP,QAAAA,QAAQ,EAAE,IAAI;AACdkC,QAAAA,YAAY,EAAEnB,iBAAiB,GAAAgB,CAAAA,qBAAA,GAAGhB,iBAAiB,CAACoB,OAAO,KAAAJ,IAAAA,GAAAA,qBAAA,GAAI,CAAC,GAAG,CAAC;QACpEK,cAAc,EAAA,CAAAJ,qBAAA,GAAErB,aAAa,CAACwB,OAAO,KAAA,IAAA,GAAAH,qBAAA,GAAI,CAAC;AAC1CK,QAAAA,UAAU,EAAE,IAAI;AAChBnC,QAAAA,KAAK,EAAE,EAAE;AACToC,QAAAA,OAAO,EAAE,KAAK;QACd9C,WAAW,EAAE,SAAS;OACvB,CAAA;AAED7B,MAAAA,WAAW,CAAC4E,IAAI,CAAC3E,KAAK,CAACU,UAAU,CAAC,CAAA;AACnC,KAAA;AAED,IAAA,IAAIkD,eAAe,EAAE;AACnB;AACA;AACA,MAAA,IAAI5D,KAAK,CAACa,gBAAgB,KAAK,IAAI,EAAE;QACnCb,KAAK,CAACW,IAAI,GAAG;UACXwB,WAAW,EAAE3B,OAAO,CAAC2B,WAAW;AAChCnB,UAAAA,KAAK,EAAE2B,kBAAkB;UACzBiC,MAAM,EAAEhC,WAAW,CAACiC,gBAAiB;AACrCC,UAAAA,QAAQ,EAAE,CAAC;AACXC,UAAAA,MAAM,EAAE,CAAA;SACT,CAAA;QAED/E,KAAK,CAACU,UAAU,CAAC4B,KAAK,CAACqC,IAAI,CAAC3E,KAAK,CAACW,IAAI,CAAC,CAAA;AACxC,OAAA;MAED,IAAIX,KAAK,CAACW,IAAI,EAAE;AACdX,QAAAA,KAAK,CAACW,IAAI,CAACmE,QAAQ,IAAI,CAAC,CAAA;AACxB9E,QAAAA,KAAK,CAACW,IAAI,CAACoE,MAAM,IAAInB,eAAe,CAAA;AACrC,OAAA;AAED;AACA;MACA5D,KAAK,CAACa,gBAAgB,GAAGqC,eAAe,GAAGA,eAAe,CAACG,aAAa,GAAG,IAAI,CAAA;AAChF,KAAA;AACF,GAAA;AAED,EAAA,IAAI,CAACrD,KAAK,CAACU,UAAU,EAAE;AACrB;AACA;AACA,IAAA,OAAO,KAAK,CAAA;AACb,GAAA;AAED,EAAA,MAAMsE,aAAa,GAAGC,WAAW,CAAC7B,gBAAgB,CAAC,CAAA;EACnD,MAAM8B,gBAAgB,GAAG/B,iBAAiB,IAAIgC,YAAY,CAACpC,aAAa,EAAEI,iBAAiB,CAAC,CAAA;AAE5F;EACA,IAAI,CAAC+B,gBAAgB,EAAE;AAAA,IAAA,IAAAE,sBAAA,CAAA;AACrBpF,IAAAA,KAAK,CAACU,UAAU,CAAC8D,cAAc,GAAAY,CAAAA,sBAAA,GAAGrC,aAAa,CAACwB,OAAO,KAAAa,IAAAA,GAAAA,sBAAA,GAAI,CAAC,CAAA;AAC7D,GAAA;AAED,EAAA,IAAI9B,aAAa,IAAIE,aAAa,IAAIE,oBAAoB,EAAE;AAC1D;IACA1D,KAAK,CAACY,YAAY,GAAG,CAAC,CAAA;AACvB,GAAA;EAED,MAAMyE,uBAAuB,GAAGrF,KAAK,CAACY,YAAY,KAAK,CAAC,IAAIoE,aAAa,CAAA;AACzE,EAAA,MAAMM,0BAA0B,GAAGtF,KAAK,CAACY,YAAY,GAAG,CAAC,CAAA;EACzD,IAAIyE,uBAAuB,IAAIC,0BAA0B,EAAE;AACzD;AACA;AACA;IACAtF,KAAK,CAACY,YAAY,IAAI,CAAC,CAAA;AACxB,GAAA;EAED,IAAI2E,eAAe,GAAG,KAAK,CAAA;AAE3B;AACA,EAAA,IAAIL,gBAAgB,EAAE;AACpBlF,IAAAA,KAAK,CAACU,UAAU,CAACgE,OAAO,GAAG,IAAI,CAAA;AAC/Ba,IAAAA,eAAe,GAAG,IAAI,CAAA;AACvB,GAAA;AAED;AACA,EAAA,IAAIvF,KAAK,CAACY,YAAY,GAAG4E,MAAM,CAACC,mBAAmB,EAAE;AACnDF,IAAAA,eAAe,GAAG,IAAI,CAAA;AACvB,GAAA;AAED;AACA,EAAA,IAAIA,eAAe,EAAE;AAAA,IAAA,IAAAG,sBAAA,CAAA;AACnB1F,IAAAA,KAAK,CAACU,UAAU,CAAC0B,QAAQ,GAAGQ,WAAW,CAAC5B,KAAK,CAAA;AAC7ChB,IAAAA,KAAK,CAACU,UAAU,CAAC+D,UAAU,GAAGtB,iBAAiB,GAAAuC,CAAAA,sBAAA,GAAGvC,iBAAiB,CAACoB,OAAO,KAAA,IAAA,GAAAmB,sBAAA,GAAI,CAAC,GAAG,CAAC,CAAA;IAEpF1F,KAAK,CAACU,UAAU,GAAG,IAAI,CAAA;IACvBV,KAAK,CAACW,IAAI,GAAG,IAAI,CAAA;AAClB,GAAA;AAED,EAAA,OAAO4E,eAAe,CAAA;AACxB;;;;"}