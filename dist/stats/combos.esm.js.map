{"version":3,"file":"combos.esm.js","sources":["../../src/stats/combos.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport last from \"lodash/last\";\n\nimport type { FrameEntryType, FramesType, GameStartType, PostFrameUpdateType } from \"../types\";\nimport type { ComboType, MoveLandedType, PlayerIndexedType } from \"./common\";\nimport {\n  calcDamageTaken,\n  didLoseStock,\n  getSinglesPlayerPermutationsFromSettings,\n  isCommandGrabbed,\n  isDamaged,\n  isDead,\n  isDown,\n  isGrabbed,\n  isTeching,\n  Timers,\n} from \"./common\";\nimport type { StatComputer } from \"./stats\";\n\nexport enum ComboEvent {\n  COMBO_START = \"COMBO_START\",\n  COMBO_EXTEND = \"COMBO_EXTEND\",\n  COMBO_END = \"COMBO_END\",\n}\n\ntype ComboState = {\n  combo: ComboType | null;\n  move: MoveLandedType | null;\n  resetCounter: number;\n  lastHitAnimation: number | null;\n  event: ComboEvent | null;\n};\n\nexport class ComboComputer extends EventEmitter implements StatComputer<ComboType[]> {\n  private playerPermutations = new Array<PlayerIndexedType>();\n  private state = new Map<PlayerIndexedType, ComboState>();\n  private combos = new Array<ComboType>();\n  private settings: GameStartType | null = null;\n\n  public setup(settings: GameStartType): void {\n    // Reset the state\n    this.settings = settings;\n    this.state = new Map();\n    this.combos = [];\n    this.playerPermutations = getSinglesPlayerPermutationsFromSettings(settings);\n\n    this.playerPermutations.forEach((indices) => {\n      const playerState: ComboState = {\n        combo: null,\n        move: null,\n        resetCounter: 0,\n        lastHitAnimation: null,\n        event: null,\n      };\n      this.state.set(indices, playerState);\n    });\n  }\n\n  public processFrame(frame: FrameEntryType, allFrames: FramesType): void {\n    this.playerPermutations.forEach((indices) => {\n      const state = this.state.get(indices);\n      if (state) {\n        handleComboCompute(allFrames, state, indices, frame, this.combos);\n\n        // Emit an event for the new combo\n        if (state.event !== null) {\n          this.emit(state.event, {\n            combo: last(this.combos),\n            settings: this.settings,\n          });\n          state.event = null;\n        }\n      }\n    });\n  }\n\n  public fetch(): ComboType[] {\n    return this.combos;\n  }\n}\n\nfunction handleComboCompute(\n  frames: FramesType,\n  state: ComboState,\n  indices: PlayerIndexedType,\n  frame: FrameEntryType,\n  combos: ComboType[],\n): void {\n  const currentFrameNumber = frame.frame;\n  const playerFrame = frame.players[indices.playerIndex]!.post;\n  const opponentFrame = frame.players[indices.opponentIndex]!.post;\n\n  const prevFrameNumber = currentFrameNumber - 1;\n  let prevPlayerFrame: PostFrameUpdateType | null = null;\n  let prevOpponentFrame: PostFrameUpdateType | null = null;\n\n  if (frames[prevFrameNumber]) {\n    prevPlayerFrame = frames[prevFrameNumber]!.players[indices.playerIndex]!.post;\n    prevOpponentFrame = frames[prevFrameNumber]!.players[indices.opponentIndex]!.post;\n  }\n\n  const oppActionStateId = opponentFrame.actionStateId!;\n  const opntIsDamaged = isDamaged(oppActionStateId);\n  const opntIsGrabbed = isGrabbed(oppActionStateId);\n  const opntIsCommandGrabbed = isCommandGrabbed(oppActionStateId);\n  const opntDamageTaken = prevOpponentFrame ? calcDamageTaken(opponentFrame, prevOpponentFrame) : 0;\n\n  // Keep track of whether actionState changes after a hit. Used to compute move count\n  // When purely using action state there was a bug where if you did two of the same\n  // move really fast (such as ganon's jab), it would count as one move. Added\n  // the actionStateCounter at this point which counts the number of frames since\n  // an animation started. Should be more robust, for old files it should always be\n  // null and null < null = false\n  const actionChangedSinceHit = playerFrame.actionStateId !== state.lastHitAnimation;\n  const actionCounter = playerFrame.actionStateCounter!;\n  const prevActionCounter = prevPlayerFrame ? prevPlayerFrame.actionStateCounter! : 0;\n  const actionFrameCounterReset = actionCounter < prevActionCounter;\n  if (actionChangedSinceHit || actionFrameCounterReset) {\n    state.lastHitAnimation = null;\n  }\n\n  // If opponent took damage and was put in some kind of stun this frame, either\n  // start a combo or count the moves for the existing combo\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed) {\n    let comboStarted = false;\n    if (!state.combo) {\n      state.combo = {\n        playerIndex: indices.opponentIndex,\n        startFrame: currentFrameNumber,\n        endFrame: null,\n        startPercent: prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0,\n        currentPercent: opponentFrame.percent ?? 0,\n        endPercent: null,\n        moves: [],\n        didKill: false,\n        lastHitBy: indices.playerIndex,\n      };\n\n      combos.push(state.combo);\n\n      // Track whether this is a new combo or not\n      comboStarted = true;\n    }\n\n    if (opntDamageTaken) {\n      // If animation of last hit has been cleared that means this is a new move. This\n      // prevents counting multiple hits from the same move such as fox's drill\n      if (state.lastHitAnimation === null) {\n        state.move = {\n          playerIndex: indices.playerIndex,\n          frame: currentFrameNumber,\n          moveId: playerFrame.lastAttackLanded!,\n          hitCount: 0,\n          damage: 0,\n        };\n\n        state.combo.moves.push(state.move);\n\n        // Make sure we don't overwrite the START event\n        if (!comboStarted) {\n          state.event = ComboEvent.COMBO_EXTEND;\n        }\n      }\n\n      if (state.move) {\n        state.move.hitCount += 1;\n        state.move.damage += opntDamageTaken;\n      }\n\n      // Store previous frame animation to consider the case of a trade, the previous\n      // frame should always be the move that actually connected... I hope\n      state.lastHitAnimation = prevPlayerFrame ? prevPlayerFrame.actionStateId : null;\n    }\n\n    if (comboStarted) {\n      state.event = ComboEvent.COMBO_START;\n    }\n  }\n\n  if (!state.combo) {\n    // The rest of the function handles combo termination logic, so if we don't\n    // have a combo started, there is no need to continue\n    return;\n  }\n\n  const opntIsTeching = isTeching(oppActionStateId);\n  const opntIsDowned = isDown(oppActionStateId);\n  const opntDidLoseStock = prevOpponentFrame && didLoseStock(opponentFrame, prevOpponentFrame);\n  const opntIsDying = isDead(oppActionStateId);\n\n  // Update percent if opponent didn't lose stock\n  if (!opntDidLoseStock) {\n    state.combo.currentPercent = opponentFrame.percent ?? 0;\n  }\n\n  if (opntIsDamaged || opntIsGrabbed || opntIsCommandGrabbed || opntIsTeching || opntIsDowned || opntIsDying) {\n    // If opponent got grabbed or damaged, reset the reset counter\n    state.resetCounter = 0;\n  } else {\n    state.resetCounter += 1;\n  }\n\n  let shouldTerminate = false;\n\n  // Termination condition 1 - player kills opponent\n  if (opntDidLoseStock) {\n    state.combo.didKill = true;\n    shouldTerminate = true;\n  }\n\n  // Termination condition 2 - combo resets on time\n  if (state.resetCounter > Timers.COMBO_STRING_RESET_FRAMES) {\n    shouldTerminate = true;\n  }\n\n  // If combo should terminate, mark the end states and add it to list\n  if (shouldTerminate) {\n    state.combo.endFrame = playerFrame.frame;\n    state.combo.endPercent = prevOpponentFrame ? prevOpponentFrame.percent ?? 0 : 0;\n    state.event = ComboEvent.COMBO_END;\n\n    state.combo = null;\n    state.move = null;\n  }\n}\n"],"names":["ComboEvent","ComboComputer","EventEmitter","constructor","args","playerPermutations","Array","state","Map","combos","settings","setup","getSinglesPlayerPermutationsFromSettings","forEach","indices","playerState","combo","move","resetCounter","lastHitAnimation","event","set","processFrame","frame","allFrames","get","handleComboCompute","emit","last","fetch","frames","currentFrameNumber","playerFrame","players","playerIndex","post","opponentFrame","opponentIndex","prevFrameNumber","prevPlayerFrame","prevOpponentFrame","oppActionStateId","actionStateId","opntIsDamaged","isDamaged","opntIsGrabbed","isGrabbed","opntIsCommandGrabbed","isCommandGrabbed","opntDamageTaken","calcDamageTaken","actionChangedSinceHit","actionCounter","actionStateCounter","prevActionCounter","actionFrameCounterReset","comboStarted","_prevOpponentFrame$pe","_opponentFrame$percen","startFrame","endFrame","startPercent","percent","currentPercent","endPercent","moves","didKill","lastHitBy","push","moveId","lastAttackLanded","hitCount","damage","COMBO_EXTEND","COMBO_START","opntIsTeching","isTeching","opntIsDowned","isDown","opntDidLoseStock","didLoseStock","opntIsDying","isDead","_opponentFrame$percen2","shouldTerminate","Timers","COMBO_STRING_RESET_FRAMES","_prevOpponentFrame$pe2","COMBO_END"],"mappings":"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"}