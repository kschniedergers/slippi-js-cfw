{"version":3,"file":"stats.esm.js","sources":["../../src/stats/stats.ts"],"sourcesContent":["import get from \"lodash/get\";\n\nimport type { FrameEntryType, FramesType, GameStartType } from \"../types\";\nimport { Frames } from \"../types\";\n\nexport interface StatComputer<T> {\n  setup(settings: GameStartType): void;\n  processFrame(newFrame: FrameEntryType, allFrames: FramesType): void;\n  fetch(): T;\n}\n\nexport type StatOptions = {\n  processOnTheFly: boolean;\n};\n\nconst defaultOptions: StatOptions = {\n  processOnTheFly: false,\n};\n\nexport class Stats {\n  private options: StatOptions;\n  private lastProcessedFrame: number | null = null;\n  private frames: FramesType = {};\n  private players: number[] = [];\n  private allComputers = new Array<StatComputer<unknown>>();\n\n  public constructor(options?: StatOptions) {\n    this.options = Object.assign({}, defaultOptions, options);\n  }\n\n  /**\n   * Should reset the frames to their default values.\n   */\n  public setup(settings: GameStartType): void {\n    // Reset the frames since it's a new game\n    this.frames = {};\n    this.players = settings.players.map((v) => v.playerIndex);\n\n    // Forward the settings on to the individual stat computer\n    this.allComputers.forEach((comp) => comp.setup(settings));\n  }\n\n  public register(...computer: StatComputer<unknown>[]): void {\n    this.allComputers.push(...computer);\n  }\n\n  public process(): void {\n    if (this.players.length === 0) {\n      return;\n    }\n\n    let i = this.lastProcessedFrame !== null ? this.lastProcessedFrame + 1 : Frames.FIRST;\n    while (this.frames[i]) {\n      const frame = this.frames[i];\n      // Don't attempt to compute stats on frames that have not been fully received\n      if (!isCompletedFrame(this.players, frame)) {\n        return;\n      }\n      this.allComputers.forEach((comp) => comp.processFrame(frame, this.frames));\n      this.lastProcessedFrame = i;\n      i++;\n    }\n  }\n\n  public addFrame(frame: FrameEntryType): void {\n    this.frames[frame.frame] = frame;\n\n    if (this.options.processOnTheFly) {\n      this.process();\n    }\n  }\n}\n\nfunction isCompletedFrame(players: number[], frame?: FrameEntryType): frame is FrameEntryType {\n  if (!frame) {\n    return false;\n  }\n\n  // This function checks whether we have successfully received an entire frame.\n  // It is not perfect because it does not wait for follower frames. Fortunately,\n  // follower frames are not used for any stat calculations so this doesn't matter\n  // for our purposes.\n  for (const player of players) {\n    const playerPostFrame = get(frame, [\"players\", player, \"post\"]);\n    if (!playerPostFrame) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"],"names":["defaultOptions","processOnTheFly","Stats","constructor","options","lastProcessedFrame","frames","players","allComputers","Array","Object","assign","setup","settings","map","v","playerIndex","forEach","comp","register","computer","push","process","length","i","Frames","FIRST","frame","isCompletedFrame","processFrame","addFrame","player","playerPostFrame","get"],"mappings":"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"}